[
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/20",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/20/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/20/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/20/events",
    "html_url": "https://github.com/axuebin/articles/issues/20",
    "id": 269268127,
    "number": 20,
    "title": "JavaScript基础心法——深浅拷贝",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-28T00:15:14Z",
    "updated_at": "2017-11-01T11:43:09Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "浅拷贝和深拷贝都是对于JS中的引用类型而言的，浅拷贝就只是复制对象的引用，如果拷贝后的对象发生变化，原对象也会发生变化。只有深拷贝才是真正地对对象的拷贝。\r\n\r\n----\r\n\r\n## 前言\r\n\r\n说到深浅拷贝，必须先提到的是JavaScript的数据类型，之前的一篇文章[JavaScript基础心法——数据类型](https://github.com/axuebin/articles/issues/3)说的很清楚了，这里就不多说了。\r\n\r\n需要知道的就是一点：JavaScript的数据类型分为基本数据类型和引用数据类型。\r\n\r\n对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的深浅拷贝都是对于引用数据类型而言的。\r\n\r\n## 浅拷贝\r\n\r\n浅拷贝的意思就是只复制引用，而未复制真正的值。\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5];\r\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\n\r\nconst cloneArray = originArray;\r\nconst cloneObj = originObj;\r\n\r\nconsole.log(cloneArray); // [1,2,3,4,5]\r\nconsole.log(originObj); // {a:'a',b:'b',c:Array[3],d:{dd:'dd'}}\r\n\r\ncloneArray.push(6);\r\ncloneObj.a = {aa:'aa'};\r\n\r\nconsole.log(cloneArray); // [1,2,3,4,5,6]\r\nconsole.log(originArray); // [1,2,3,4,5,6]\r\n\r\nconsole.log(cloneObj); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}\r\nconsole.log(originArray); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}\r\n```\r\n\r\n上面的代码是最简单的利用 `=` 赋值操作符实现了一个浅拷贝，可以很清楚的看到，随着 `cloneArray` 和 `cloneObj` 改变，`originArray` 和 `originObj` 也随着发生了变化。\r\n\r\n## 深拷贝\r\n\r\n深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。\r\n\r\n只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。\r\n\r\n目前实现深拷贝的方法不多，主要是两种：\r\n\r\n1. 利用 `JSON` 对象中的 `parse` 和 `stringify`\r\n2. 利用递归来实现每一层都重新创建对象并赋值\r\n\r\n### JSON.stringify/parse的方法\r\n\r\n先看看这两个方法吧：\r\n\r\n> The JSON.stringify() method converts a JavaScript value to a JSON string.\r\n\r\n`JSON.stringify` 是将一个 `JavaScript` 值转成一个 `JSON` 字符串。\r\n\r\n> The JSON.parse() method parses a JSON string, constructing the JavaScript value or object described by the string.\r\n\r\n`JSON.parse` 是将一个 `JSON` 字符串转成一个 `JavaScript` 值或对象。\r\n\r\n很好理解吧，就是 `JavaScript` 值和 `JSON` 字符串的相互转换。\r\n\r\n它能实现深拷贝呢？我们来试试。\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5];\r\nconst cloneArray = JSON.parse(JSON.stringify(originArray));\r\nconsole.log(cloneArray === originArray); // false\r\n\r\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\nconst cloneObj = JSON.parse(JSON.stringify(originObj));\r\nconsole.log(cloneObj === originObj); // false\r\n\r\ncloneObj.a = 'aa';\r\ncloneObj.c = [1,1,1];\r\ncloneObj.d.dd = 'doubled';\r\n\r\nconsole.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};\r\nconsole.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\n```\r\n\r\n确实是深拷贝，也很方便。但是，这个方法只能适用于一些简单的情况。比如下面这样的一个对象就不适用：\r\n\r\n```javascript\r\nconst originObj = {\r\n  name:'axuebin',\r\n  sayHello:function(){\r\n    console.log('Hello World');\r\n  }\r\n}\r\nconsole.log(originObj); // {name: \"axuebin\", sayHello: ƒ}\r\nconst cloneObj = JSON.parse(JSON.stringify(originObj));\r\nconsole.log(cloneObj); // {name: \"axuebin\"}\r\n```\r\n\r\n发现在 `cloneObj` 中，有属性丢失了。。。那是为什么呢？\r\n\r\n在 `MDN` 上找到了原因：\r\n\r\n>If undefined, a function, or a symbol is encountered during conversion it is either omitted (when it is found in an object) or censored to null (when it is found in an array). JSON.stringify can also just return undefined when passing in \"pure\" values like JSON.stringify(function(){}) or JSON.stringify(undefined).\r\n\r\n`undefined`、`function`、`symbol` 会在转换过程中被忽略。。。\r\n\r\n明白了吧，就是说如果对象中含有一个函数时（很常见），就不能用这个方法进行深拷贝。\r\n\r\n### 递归的方法\r\n\r\n递归的思想就很简单了，就是对每一层的数据都实现一次 `创建对象->对象赋值` 的操作，简单粗暴上代码：\r\n\r\n```javascript\r\nfunction deepClone(source){\r\n  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象\r\n  for(let keys in source){ // 遍历目标\r\n    if(source.hasOwnProperty(keys)){\r\n      if(source[keys] && typeof source[keys] === 'object'){ // 如果值是对象，就递归一下\r\n        targetObj[keys] = source[keys].constructor === Array ? [] : {};\r\n        targetObj[keys] = deepClone(source[keys]);\r\n      }else{ // 如果不是，就直接赋值\r\n        targetObj[keys] = source[keys];\r\n      }\r\n    } \r\n  }\r\n  return targetObj;\r\n}\r\n```\r\n\r\n我们来试试：\r\n\r\n```javascript\r\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\nconst cloneObj = deepClone(originObj);\r\nconsole.log(cloneObj === originObj); // false\r\n\r\ncloneObj.a = 'aa';\r\ncloneObj.c = [1,1,1];\r\ncloneObj.d.dd = 'doubled';\r\n\r\nconsole.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};\r\nconsole.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\n```\r\n\r\n可以。那再试试带有函数的：\r\n\r\n```javascript\r\nconst originObj = {\r\n  name:'axuebin',\r\n  sayHello:function(){\r\n    console.log('Hello World');\r\n  }\r\n}\r\nconsole.log(originObj); // {name: \"axuebin\", sayHello: ƒ}\r\nconst cloneObj = deepClone(originObj);\r\nconsole.log(cloneObj); // {name: \"axuebin\", sayHello: ƒ}\r\n```\r\n\r\n也可以。搞定。\r\n\r\n是不是以为这样就完了？？ 当然不是。\r\n\r\n## JavaScript中的拷贝方法\r\n\r\n我们知道在 `JavaScript` 中，数组有两个方法 `concat` 和 `slice` 是可以实现对原数组的拷贝的，这两个方法都不会修改原数组，而是返回一个修改后的新数组。\r\n\r\n同时，ES6 中 引入了 `Object.assgn` 方法和 `...` 展开运算符也能实现对对象的拷贝。\r\n \r\n那它们是浅拷贝还是深拷贝呢？\r\n\r\n### concat\r\n\r\n> The concat() method is used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array.\r\n\r\n该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。\r\n\r\n看着这意思，很像是深拷贝啊，我们来试试：\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5];\r\nconst cloneArray = originArray.concat();\r\n\r\nconsole.log(cloneArray === originArray); // false\r\ncloneArray.push(6); // [1,2,3,4,5,6]\r\nconsole.log(originArray); [1,2,3,4,5];\r\n```\r\n\r\n看上去是深拷贝的。\r\n\r\n我们来考虑一个问题，如果这个对象是多层的，会怎样。\r\n\r\n```javascript\r\nconst originArray = [1,[1,2,3],{a:1}];\r\nconst cloneArray = originArray.concat();\r\nconsole.log(cloneArray === originArray); // false\r\ncloneArray[1].push(4);\r\ncloneArray[2].a = 2; \r\nconsole.log(originArray); // [1,[1,2,3,4],{a:2}]\r\n```\r\n\r\n`originArray` 中含有数组 `[1,2,3]` 和对象 `{a:1}`，如果我们直接修改数组和对象，不会影响 `originArray`，但是我们修改数组 `[1,2,3]` 或对象 `{a:1}` 时，发现 `originArray` 也发生了变化。 \r\n\r\n**结论：`concat` 只是对数组的第一层进行深拷贝。**\r\n\r\n### slice\r\n\r\n> The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included). The original array will not be modified.\r\n\r\n解释中都直接写道是 `a shallow copy` 了 ~\r\n\r\n但是，并不是！\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5];\r\nconst cloneArray = originArray.slice();\r\n\r\nconsole.log(cloneArray === originArray); // false\r\ncloneArray.push(6); // [1,2,3,4,5,6]\r\nconsole.log(originArray); [1,2,3,4,5];\r\n```\r\n\r\n同样地，我们试试多层的数组。\r\n\r\n```javascript\r\nconst originArray = [1,[1,2,3],{a:1}];\r\nconst cloneArray = originArray.slice();\r\nconsole.log(cloneArray === originArray); // false\r\ncloneArray[1].push(4);\r\ncloneArray[2].a = 2; \r\nconsole.log(originArray); // [1,[1,2,3,4],{a:2}]\r\n```\r\n\r\n果然，结果和 `concat` 是一样的。\r\n\r\n**结论：`slice` 只是对数组的第一层进行深拷贝。**\r\n\r\n### Object.assign()\r\n\r\n> The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.\r\n\r\n复制复制复制。\r\n\r\n那到底是浅拷贝还是深拷贝呢？\r\n\r\n自己试试吧。。\r\n\r\n**结论：`Object.assign()` 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。**\r\n\r\n### ... 展开运算符\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5,[6,7,8]];\r\nconst originObj = {a:1,b:{bb:1}};\r\n\r\nconst cloneArray = [...originArray];\r\ncloneArray[0] = 0;\r\ncloneArray[5].push(9);\r\nconsole.log(originArray); // [1,2,3,4,5,[6,7,8,9]]\r\n\r\nconst cloneObj = {...originObj};\r\ncloneObj.a = 2;\r\ncloneObj.b.bb = 2;\r\nconsole.log(originObj); // {a:1,b:{bb:2}}\r\n```\r\n\r\n**结论：`...` 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。**\r\n\r\n\r\n### 首层浅拷贝\r\n\r\n我们知道了，会有一种情况，就是对目标对象的第一层进行深拷贝，然后后面的是浅拷贝，可以称作“首层浅拷贝”。\r\n\r\n我们可以自己实现一个这样的函数：\r\n\r\n```javascript\r\nfunction shallowClone(source) {\r\n  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象\r\n  for (let keys in source) { // 遍历目标\r\n    if (source.hasOwnProperty(keys)) {\r\n      targetObj[keys] = source[keys];\r\n    }\r\n  }\r\n  return targetObj;\r\n}\r\n```\r\n\r\n我们来测试一下：\r\n\r\n```javascript\r\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\nconst cloneObj = shallowClone(originObj);\r\nconsole.log(cloneObj === originObj); // false\r\ncloneObj.a='aa';\r\ncloneObj.c=[1,1,1];\r\ncloneObj.d.dd='surprise';\r\n```\r\n\r\n经过上面的修改，`cloneObj` 不用说，肯定是 `{a:'aa',b:'b',c:[1,1,1],d:{dd:'surprise'}}` 了，那 `originObj` 呢？刚刚我们验证了 `cloneObj === originObj` 是 `false`，说明这两个对象引用地址不同啊，那应该就是修改了 `cloneObj` 并不影响 `originObj`。\r\n\r\n```javascript\r\nconsole.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'surprise'}}\r\nconsole.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'surprise'}}\r\n```\r\n\r\nWhat happend?\r\n\r\n`originObj` 中关于 `a`、`c`都没被影响，但是 `d` 中的一个对象被修改了。。。说好的深拷贝呢？不是引用地址都不一样了吗？\r\n\r\n原来是这样：\r\n\r\n1. 从 `shallowClone` 的代码中我们可以看出，我们只对第一层的目标进行了 `深拷贝` ，而第二层开始的目标我们是直接利用 `=` 赋值操作符进行拷贝的。\r\n2. so，第二层后的目标都只是复制了一个引用，也就是浅拷贝。\r\n\r\n## 总结\r\n\r\n1. 赋值运算符 `=` 实现的是浅拷贝，只拷贝对象的引用值；\r\n2. JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”；\r\n3. `JSON.stringify` 实现的是深拷贝，但是对目标对象有要求；\r\n4. 若想真正意义上的深拷贝，请递归。"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/19",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/19/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/19/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/19/events",
    "html_url": "https://github.com/axuebin/articles/issues/19",
    "id": 268960407,
    "number": 19,
    "title": "2017年年末2个月计划",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 725736221,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%BF%83%E6%83%85",
        "name": "心情",
        "color": "d93f0b",
        "default": false
      },
      {
        "id": 725737700,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E7%A2%8E%E7%A2%8E%E5%BF%B5",
        "name": "碎碎念",
        "color": "ff9900",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 1,
    "created_at": "2017-10-27T01:24:58Z",
    "updated_at": "2017-10-27T01:25:51Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "首先希望最近能把工作的事搞定吧。\r\n\r\n因为要毕业了，所以这几个月的重心就是写论文，争取1月份能去实习。\r\n\r\n- 写论文\r\n- 之前准备笔试面试遇到的问题深入理解一下， 写文章\r\n- 关注前端技术的变化，每天还是要看一些文章\r\n- 能在sf上多回答几个问题\r\n- 学点数据结构"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/13",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/13/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/13/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/13/events",
    "html_url": "https://github.com/axuebin/articles/issues/13",
    "id": 267470869,
    "number": 13,
    "title": "JavaScript数据结构及算法——查找",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 723280030,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95",
        "name": "数据结构及算法",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-22T14:48:15Z",
    "updated_at": "2017-10-30T09:12:34Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "本文主要记录的是JavaScript实现常用的查找算法。\r\n\r\n----\r\n\r\n## 前言\r\n\r\n用JavaScript写算法是种怎么样的体验？不喜欢算法的我最近也对数据结构和算法有点兴趣。。。所以，将会有这些：\r\n\r\n- JavaScript数据结构及算法——栈\r\n- JavaScript数据结构及算法——队列\r\n- JavaScript数据结构及算法——链表\r\n- [JavaScript数据结构及算法——排序](https://github.com/axuebin/articles/issues/12)\r\n- [JavaScript数据结构及算法——查找](https://github.com/axuebin/articles/issues/13)\r\n- JavaScript数据结构及算法——树\r\n\r\n现阶段我对于数据结构、算法的理解还很浅，希望各位大佬多多指导。\r\n\r\n## 查找\r\n\r\n> 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。\r\n\r\n这里主要提到如何用JavaScript实现顺序查找和二分查找。\r\n\r\n## 顺序查找\r\n\r\n**主要思想**：将每一个数据结构中的元素和要查找的元素做比较，类似于JavaScript中indexOf\r\n\r\n**时间复杂度**：O(n)\r\n\r\n代码：\r\n\r\n```javascript\r\nfunction sequentialSearch(array,item){\r\n  for (let i = 0; i < array.length; i += 1) {\r\n    if ( item === array[i] ) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n```\r\n\r\n比如我现在有这样一个数组 `[5, 4, 3, 2, 1]` ，然后我们需要在其中找到 `3` ，整个流程应该是这样：\r\n\r\n```javascript\r\n[5, 4, 3, 2, 1] // 5 !== 3，继续遍历\r\n[5, 4, 3, 2, 1] // 4 !== 3，继续遍历\r\n[5, 4, 3, 2, 1] // 3 === 3，找到了\r\n```\r\n\r\n## 二分查找\r\n\r\n**主要思想**：首先这个数组是排好序的，然后将数组一直二分缩小范围，直到找到为止。\r\n\r\n**时间复杂度**：O(logn)\r\n\r\n代码：\r\n\r\n```javascript\r\nfunction binarySearch(array, item) {\r\n  const sortArray = quickSort(array); // 对数组进行快排\r\n  let low = 0; // 设置左边界\r\n  let high = sortArray.length - 1; // 设置右边界\r\n  let mid = 0; // 设置中间值\r\n  let element = 0;\r\n  while (low < high) {\r\n    mid = Math.floor((low + high) / 2); // 选择整个数组的中间值\r\n    element = sortArray[mid];\r\n    if (element < item) { // 如果待搜索值比选中值要大，则返回步骤一在右边的字数组中寻找\r\n      low = mid + 1;\r\n    } else if (element > item) { // 如果待搜索值比选中值要小，则返回步骤一在左边的字数组中寻找\r\n      high = mid - 1;\r\n    } else {\r\n      return mid; // 如果刚好选中，恭喜你，直接返回\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n```"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/12",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/12/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/12/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/12/events",
    "html_url": "https://github.com/axuebin/articles/issues/12",
    "id": 267380423,
    "number": 12,
    "title": "JavaScript数据结构及算法——排序",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 723280030,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95",
        "name": "数据结构及算法",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-21T13:33:03Z",
    "updated_at": "2017-10-30T01:58:43Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "本文主要记录的是JavaScript实现常用的排序算法，冒泡排序、快速排序、归并排序等。\r\n\r\n----\r\n\r\n## 前言\r\n\r\n用JavaScript写算法是种怎么样的体验？不喜欢算法的我最近也对数据结构和算法有点兴趣。。。所以，将会有这些：\r\n\r\n- JavaScript数据结构及算法——栈\r\n- JavaScript数据结构及算法——队列\r\n- JavaScript数据结构及算法——链表\r\n- [JavaScript数据结构及算法——排序](https://github.com/axuebin/articles/issues/12)\r\n- [JavaScript数据结构及算法——查找](https://github.com/axuebin/articles/issues/13)\r\n- JavaScript数据结构及算法——树\r\n\r\n现阶段我对于数据结构、算法的理解还很浅，希望各位大佬多多指导。\r\n\r\n## 排序\r\n\r\n> 介绍排序算法\r\n\r\n## 冒泡排序\r\n\r\n说到冒泡排序，大家都很熟悉，顾名思义，是一种“冒泡”的过程。\r\n\r\n**主要思想**：比较任何两个相邻的项，如果第一个比第二个大，则交换它们。\r\n\r\n**时间复杂度**：O(n2)\r\n\r\n**空间复杂度**：O(1)\r\n\r\n如何实现呢？是不是遍历所有需要排序的数据，然后将它和所有数比较一次，然后就可以了？\r\n\r\n道理是有的，我们试试看：\r\n\r\n```javascript\r\nfunction bubbleSort(arr) {\r\n  const len = arr.length; // 声明一个len来存储数组的长度\r\n  let temp = 0;\r\n  for (let i = 0; i < len; i += 1) { // 外循环遍历数组\r\n    for (let j = 0 ; j < len - 1 ; j += 1) { // 内循环执行当前项和下一项进行比较\r\n      if (arr[j] > arr[j + 1]) {  // 如果当前项比下一项大，则交换它们\r\n        temp = arr[j];\r\n        arr[j] = arr[j + 1];\r\n        arr[j + 1] = temp;\r\n      }\r\n      console.log(arr);\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n我们通过输出数组来看一下整个流程：\r\n\r\n```javascript\r\n[5, 4, 3, 2, 1] \r\n[4, 5, 3, 2, 1] // 5>4，交换\r\n[4, 3, 5, 2, 1] // 5>3，交换\r\n[4, 3, 2, 5, 1] // 5>2，交换\r\n[4, 3, 2, 1, 5] // 5>1，交换\r\n[3, 4, 2, 1, 5] // 4>3，交换\r\n[3, 2, 4, 1, 5] // 4>2，交换\r\n[3, 2, 1, 4, 5] // 4>1，交换\r\n[3, 2, 1, 4, 5] // 4<5，不交换\r\n[2, 3, 1, 4, 5] // 3>2，交换\r\n[2, 1, 3, 4, 5] // 3>1，交换\r\n[2, 1, 3, 4, 5] // 3<4，不交换\r\n[2, 1, 3, 4, 5] // 4<5，不交换\r\n[1, 2, 3, 4, 5] // 2>1，交换\r\n[1, 2, 3, 4, 5] // 2<3，不交换\r\n[1, 2, 3, 4, 5] // 3<4，不交换\r\n[1, 2, 3, 4, 5] // 4<5，不交换\r\n[1, 2, 3, 4, 5] // 1<2，不交换\r\n[1, 2, 3, 4, 5] // 2<3，不交换\r\n[1, 2, 3, 4, 5] // 3<4，不交换\r\n[1, 2, 3, 4, 5] // 4<5，不交换\r\n```\r\n\r\n排序确实是排好了，但是我们发现，有很多的不必要的比较，我们应该想办法避免这些。想一想，这些都是在内循环中对已经排序过的数进行比较，所以我们可以稍稍改进一下代码：\r\n\r\n```javascript\r\nfunction bubbleSort(arr) {\r\n  const len = arr.length;\r\n  let temp = 0;\r\n  for (let i = 0; i < len; i += 1) {\r\n    for (let j = 0 ; j < len - 1 - i ; j += 1) {\r\n      if (arr[j] > arr[j + 1]) {\r\n        temp = arr[j];\r\n        arr[j] = arr[j + 1];\r\n        arr[j + 1] = temp;\r\n      }\r\n      console.log(arr);\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n在内循环中，我们另 `j` 的取值到 `len-1-i` 为止，因为再往后的数已经排序好了。同样地，我们来看看流程：\r\n\r\n```javascript\r\n[5, 4, 3, 2, 1] \r\n[4, 5, 3, 2, 1] // 5>4，交换\r\n[4, 3, 5, 2, 1] // 5>3，交换\r\n[4, 3, 2, 5, 1] // 5>2，交换\r\n[4, 3, 2, 1, 5] // 5>1，交换\r\n[3, 4, 2, 1, 5] // 4>3，交换\r\n[3, 2, 4, 1, 5] // 4>2，交换\r\n[3, 2, 1, 4, 5] // 4>1，交换\r\n[2, 3, 1, 4, 5] // 3>2，交换\r\n[2, 1, 3, 4, 5] // 3>1，交换\r\n[1, 2, 3, 4, 5] // 2>1，交换\r\n```\r\n\r\nnice，没必要的比较已经完全没有了。\r\n\r\n## 选择排序\r\n\r\n**主要思想**：找到数组中的最小值然后将其放置在第一位，接着第二位第三位。。。\r\n\r\n**时间复杂度**：O(n2)\r\n\r\n**空间复杂度**：O(1)\r\n\r\n直接看代码吧：\r\n\r\n```javascript\r\nfunction selectionSort(arr) {\r\n  const len = arr.length; // 用len存储数组长度\r\n  let indexMin = 0; // 最小值索引\r\n  let temp = 0;\r\n  for (let i = 0; i < len - 1; i += 1) { //外循环遍历数组\r\n    indexMin = i; // 先假设这一轮循环的第一个值是最小的\r\n    for (let j = i; j < len; j += 1) { // 比较i时候会比它之后的数小，如果小，则令indexMin存储这个更小值的索引\r\n       if (arr[indexMin] > arr[j]) {\r\n        indexMin = j;\r\n      }\r\n    }\r\n    if (i !== indexMin) { // 执行完内循环之后判断当前值i是否是最小的，如果不是，就要交换\r\n      temp = arr[i];\r\n      arr[i] = arr[indexMin];\r\n      arr[indexMin] = temp;\r\n    }\r\n    console.log(arr);\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n```javascript\r\n[5, 4, 3, 2, 1] \r\n[1, 4, 3, 2, 5] // 寻找最小值1，交换1和5\r\n[1, 2, 3, 4, 5] // 寻找最小值2，交换2和4\r\n[1, 2, 3, 4, 5] // 寻找最小值3，不交换\r\n[1, 2, 3, 4, 5] // 寻找最小值4，不交换\r\n[1, 2, 3, 4, 5] // 寻找最小值5，不交换\r\n```\r\n\r\n是不是很酷，然而它的时间复杂度其实还是 `O(n2)`。\r\n\r\n## 插入排序\r\n\r\n**主要思想**：每次将一个元素与已排序的元素进行逐一比较，直到找到合适的位置按大小插入。\r\n\r\n**时间复杂度**：O(n2)\r\n\r\n**空间复杂度**：O(1)\r\n\r\n直接看代码吧：\r\n\r\n```javascript\r\nfunction insertionSort(arr) {\r\n  const len = arr.length; // 数组长度\r\n  let j = 0; // 使用的辅助变量\r\n  let temp = 0;\r\n  for (let i = 1; i < len; i++) { // 外循环，从1开始\r\n    j = i; // 当前索引赋给j\r\n    temp = arr[i]; // 当前值存在temp\r\n    while (j > 0 && arr[j - 1] > temp) { // 如果j前面的数比它大，就往前移，直到第一位\r\n      arry[j] = arr[j - 1];\r\n      j--;\r\n    }\r\n    arr[j] = temp; // temp是要排序的那个数，放到正确的j的位置上\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n## 归并排序\r\n\r\n**主要思想**：思想主要是分治。将原始数组划分成较小的数组，直到每个小数组只有一个位置，然后将小数组归并成较大的数组。\r\n\r\n**时间复杂度**：O(nlogn)\r\n\r\n**空间复杂度**：O(n)\r\n\r\n直接看代码吧：\r\n\r\n```javascript\r\n// 分\r\nfunction mergeSort(arr) {\r\n  const len = arr.length;\r\n  if (len === 1) {\r\n    return arr;\r\n  }\r\n  const mid = Math.floor(len / 2);\r\n  const left = arr.slice(0, mid);\r\n  const right = arr.slice(mid, len);\r\n  return merge(mergeSort(left), mergeSort(right));\r\n}\r\n \r\n// 合\r\nfunction merge(left, right) {\r\n  const result = [];\r\n  let il = 0;\r\n  let ir = 0;\r\n  while (il < left.length && ir < right.length) {\r\n    if (left[il] < right[ir]) {\r\n      result.push(left[il++]);\r\n    } else {\r\n      result.push(right[ir++]);\r\n    }\r\n  }\r\n  while (il < left.length) {\r\n    result.push(left[il++]);\r\n  }\r\n  while (ir < right.length) {\r\n    result.push(right[ir++]);\r\n  }\r\n  return result;\r\n}\r\n```\r\n\r\n## 快速排序\r\n\r\n来看看面试中最喜欢考察的快速排序。\r\n\r\n**主要思想**：每次将一个元素与已排序的元素进行逐一比较，直到找到合适的位置按大小插入。\r\n\r\n**时间复杂度**：O(nlogn)\r\n\r\n**空间复杂度**：O(logn)\r\n\r\n```javascript\r\nfunction quickSort(arr) {\r\n  if (arr.length <= 1) {\r\n    return arr;\r\n  }\r\n  const pivotIndex = Math.floor(arr.length / 2);\r\n  const pivot = arr.splice(pivotIndex, 1)[0]; // 将这个元素取出并从原数组中删除\r\n  const left = [];\r\n  const right = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (arr[i] < pivot) {\r\n      left.push(arr[i]);\r\n    } else {\r\n      right.push(arr[i]);\r\n    }\r\n  }\r\n  return quickSort(left).concat(pivot, quickSort(right));\r\n}\r\n```"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/10",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/10/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/10/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/10/events",
    "html_url": "https://github.com/axuebin/articles/issues/10",
    "id": 266367921,
    "number": 10,
    "title": "关于浏览器缓存我知道多少",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 725736399,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E7%BC%93%E5%AD%98",
        "name": "缓存",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 723279884,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E7%BD%91%E7%BB%9C%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8",
        "name": "网络及浏览器",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2017-10-18T05:56:12Z",
    "updated_at": "2017-10-30T03:25:13Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "在前端开发中，我们在提到性能优化的时候总会提到一点：合理设置缓存。我们该如何从这方面入手来考虑提高网站性能呢？\r\n\r\n----\r\n\r\n### 前言\r\n\r\n我们都知道 HTML5 引入了应用程序缓存，可以在没有网络的情况下进行访问，同时，HTML5 还引入了 storage 本地存储。这些都属于应用缓存。\r\n\r\n本篇文章主要内容是和浏览器缓存相关的，也可以说是 HTTP 缓存。\r\n\r\n### 什么是浏览器缓存\r\n\r\nMDN 上是这样解释浏览器缓存的：\r\n\r\n> A browser cache holds all documents downloaded via HTTP by the user ... without requiring an additional trip to the server. \r\n\r\n意思就是，浏览器缓存保存着用户通过 `HTTP` 获取的所有资源，再下一次请求时可以避免重复向服务器发出多余的请求。\r\n\r\n通俗的说，就是在你访问过一次某个网站之后，这个站点的文字、图片等所有资源都被下载到本地了，下次再访问该网站时判断是否满足缓存条件，如果满足就不用再花费时间去等待资源的获取了。\r\n\r\n### 浏览器缓存的分类\r\n\r\n一般来说浏览器缓存可以分为两类：\r\n\r\n- 强缓存\r\n- 协商缓存（对比缓存）\r\n\r\n我们需要知道的是，浏览器在加载资源时，会先判断是否命中**强缓存**再验证是命中**协商缓存**。\r\n\r\n其它的的具体细节，稍后会展开来说。\r\n\r\n### 强缓存\r\n\r\n浏览器在加载资源时，会先根据本地缓存资源的 `header` 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/%E5%BC%BA%E7%BC%93%E5%AD%98.png)\r\n\r\n从图中可以看出，强缓存一般是这样一个流程：\r\n\r\n1. 查看 `header` 头中的 `Expire` 和 `Cache-control` 来判断是否满足规则；\r\n2. 如果满足规则，就返回缓存的数据；\r\n3. 如果不满足规则，就向服务器发送请求；\r\n4. 服务器返回数据；\r\n5. 将新数据存入缓存。\r\n\r\n所以我们主要就是关注 `Expire` 和 `Cache-control` 这两个字段。\r\n\r\n#### Expire\r\n\r\n同样地，我们看看MDN中如何解释这个字段：\r\n\r\n> The Expires header contains the date/time after which the response is considered stale.\r\n\r\n这个字段包含了一个时间，过了这个时间，响应将会失效。\r\n\r\n也就是说，`Expire` 这个字段表示缓存到期时间，我们来打开一个网站并查看 `Response Header` 看看这个字段：\r\n\r\n```\r\nExpires:Fri, 27 Oct 2017 07:55:30 GMT\r\n```\r\n\r\n可能在你查看这的时候发现时间不对啊，怎么都已经是过去了 ~ \r\n\r\n`GMT` 表示的是格林威治时间，和北京时间相差8小时。\r\n\r\n上面的这个时间表示的是 `2017年10月27日15:55:30`。\r\n\r\n通过设置 `Expire` 来设置缓存有一个致命缺点：\r\n\r\n可以看出，这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢。\r\n\r\n#### Cache-Control\r\n\r\n既然不能设置绝对时间，那我就设置个相对时间呗。\r\n\r\n在 `HTTP/1.1` 中，增加了一个字段 `Cache-Control` ，它包含一个 `max-age` 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间。\r\n\r\n```\r\nCache-Control:max-age=600\r\n```\r\n\r\n这个表示的就是最大有效时间是 `600s` ，对的，它的单位是秒。\r\n\r\n`Cache-Control` 除了 `max-age` 属性之外还有一些属性：\r\n\r\n- no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。\r\n- no-store：禁止使用缓存，每一次都要重新请求数据。\r\n- public：默认设置。\r\n- private：不能被多用户共享。\r\n\r\n现在基本上都会同时设置 `Expire` 和 `Cache-Control` ，`Cache-Control` 的优先级别更高。\r\n\r\n### 协商缓存\r\n\r\n当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据请求头中的部分信息来判断是否命中缓存。如果命中，则返回 `304` ，告诉浏览器资源未更新，可使用本地的缓存。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png)\r\n\r\n从图中可以看出，协商缓存一般是这样一个流程：\r\n\r\n1. 把资源标识，比如 `If-Modify-Since` 或 `Etag` 发送到服务器，确认资源是否更新；\r\n2. 如果资源未更新，请求响应返回的http状态为 `304` 并且会显示一个 `Not Modified` 的字符串，告诉浏览器使用本地缓存;\r\n3. 如果资源已经更新，返回新的数据； \r\n4. 将新数据存入缓存。\r\n\r\n#### Last-Modified，If-Modified-Since\r\n\r\n浏览器第一次请求资源的时候，服务器返回的 `header` 上会带有一个 `Last-Modified` 字段，表示资源**最后修改**的时间。\r\n\r\n```\r\nLast-Modified: Fri, 27 Oct 2017 07:55:30 GMT\r\n```\r\n\r\n同样的，这是一个 `GMT` 的绝对时间。\r\n\r\n当浏览器再次请求该资源时，请求头中会带有一个 `If-Modified-Since` 字段，这个值是第一次请求返回的 `Last-Modified` 的值。服务器收到这个请求后，将 `If-Modified-Since` 和当前的 `Last-Modified` 进行对比。如果相等，则说明资源未修改，返回 `304`，浏览器使用本地缓存。\r\n\r\nwell，这个方法也是有缺点的：\r\n\r\n- 最小单位是秒。也就是说如果我短时间内资源发生了改变，`Last-Modified` 并不会发生变化；\r\n- 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 `Last-Modified` 可不这样认为。\r\n\r\n所以，后来又引入一个 `Etag`。\r\n\r\n#### Etag\r\n\r\n`Etag` 一般是由文件内容 `hash` 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 `Etag` 发生改变。\r\n\r\n同样地，在浏览器第一次请求资源时，服务器会返回一个 `Etag` 标识。当再次请求该资源时， 会通过 `If-no-match` 字段将 `Etag` 发送回服务器，然后服务器进行比较，如果相等，则返回 `304` 表示未修改。\r\n\r\n**`Last-Modified` 和 `Etag` 是可以同时设置的，服务器会优先校验 `Etag`，如果 `Etag` 相等就会继续比对 `Last-Modified`，最后才会决定是否返回 `304`。 **\r\n\r\n### 总结\r\n\r\n当浏览器再次访问一个已经访问过的资源时，它会这样做：\r\n\r\n1. 看看是否命中强缓存，如果命中，就直接使用缓存了；\r\n2. 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；\r\n3. 如果命中协商缓存，服务器会返回 `304` 告诉浏览器使用本地缓存；\r\n4. 否则，返回最新的资源。"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/9",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/9/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/9/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/9/events",
    "html_url": "https://github.com/axuebin/articles/issues/9",
    "id": 265628032,
    "number": 9,
    "title": "React V15.6 实现一个简单的个人博客",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720883916,
        "url": "https://api.github.com/repos/axuebin/articles/labels/CSS",
        "name": "CSS",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720883997,
        "url": "https://api.github.com/repos/axuebin/articles/labels/ES6",
        "name": "ES6",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884233,
        "url": "https://api.github.com/repos/axuebin/articles/labels/React",
        "name": "React",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-16T02:14:18Z",
    "updated_at": "2017-10-20T10:55:13Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "学习 React 的过程中实现了一个个人主页，没有复杂的实现和操作，适合入门 ~\r\n\r\n----\r\n\r\n这个项目其实功能很简单，就是常见的主页、博客、demo、关于我等功能。\r\n\r\n页面样式都是自己写的，黑白风格，可能有点丑。不过还是最低级的 CSS ，准备到时候重构 ~\r\n\r\n如果有更好的方法，或者是我的想法有偏差的，欢迎大家交流指正\r\n\r\n欢迎参观：[http://axuebin.com/react-blog](http://axuebin.com/react-blog)\r\n\r\nGithub：[https://github.com/axuebin/react-blog](https://github.com/axuebin/react-blog)\r\n\r\n## 预览图\r\n\r\n### 首页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E9%A6%96%E9%A1%B5.png)\r\n\r\n### 博客页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%8D%9A%E5%AE%A2%E9%A1%B5.png)\r\n\r\n### 文章内容页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9.png)\r\n\r\n### Demo页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/articledemo%E9%A1%B5.png)\r\n\r\n## 关键技术\r\n\r\n- ES6：项目中用到 ES6 的语法，在写的过程中尽量使用，可能有的地方没想到\r\n- React\r\n- React-Router：前端路由\r\n- React-Redux：状态管理\r\n- webpack：打包\r\n- marked：Markdown渲染\r\n- highlight.js：代码高亮\r\n- fetch：异步请求数据\r\n- eslint：代码检查\r\n- antd：部分组件懒得自己写。。\r\n\r\n## 准备工作\r\n\r\n由于不是使用 React 脚手架生成的项目，所以每个东西都是自己手动配置的。。。\r\n\r\n### 模块打包器\r\n\r\n打包用的是 `webpack 2.6.1`，准备入坑 `webpack 3` 。\r\n\r\n官方文档：[https://webpack.js.org/](https://webpack.js.org/)\r\n\r\n中文文档：[https://doc.webpack-china.org/](https://doc.webpack-china.org/)\r\n\r\n对于 `webpack` 的配置还不是太熟，就简单的配置了一下可供项目启动：\r\n\r\n```javascript\r\nvar webpack = require('webpack');\r\nvar path = require('path');\r\n\r\nmodule.exports = {\r\n  context: __dirname + '/src',\r\n  entry: \"./js/index.js\",\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.js?$/,\r\n        exclude: /(node_modules)/,\r\n        loader: 'babel-loader',\r\n        query: {\r\n          presets: ['react', 'es2015']\r\n        }\r\n      }, {\r\n        test: /\\.css$/,\r\n        loader: 'style-loader!css-loader'\r\n      }, {\r\n        test: /\\.js$/,\r\n        exclude: /(node_modules)/,\r\n        loader: 'eslint-loader'\r\n      }, {\r\n        test: /\\.json$/,\r\n        loader: 'json-loader'\r\n      }\r\n    ]\r\n  },\r\n  output: {\r\n    path: __dirname + \"/src/\",\r\n    filename: \"bundle.js\"\r\n  }\r\n}\r\n\r\n```\r\n\r\n`webpack` 有几个重要的属性：`entry`、`module`、`output`、`plugins`，在这里我还没使用到插件，所以没有配置 `plugins` 。\r\n\r\n`module` 中的 `loaders`：\r\n\r\n- babel-loader：将代码转换成es5代码\r\n- css-loader：处理css中路径引用等问题\r\n- style-loader：动态把样式写入css\r\n- eslin-loader：使用eslint\r\n\r\n### 包管理\r\n\r\n包管理现在使用的还是 `NPM` 。\r\n\r\n官方文档：[https://docs.npmjs.com/](https://docs.npmjs.com/)\r\n\r\n1. npm init\r\n2. npm install\r\n3. npm uninstall\r\n\r\n关于`npm`，可能还需要了解 `dependencies` 和 `devDependencies` 的区别，我是这样简单理解的：\r\n\r\n- dependencies：项目跑起来后需要使用到的模块\r\n- devDependencies：开发的时候需要用的模块，但是项目跑起来后就不需要了\r\n\r\n### 代码检查\r\n\r\n项目使用现在比较流行的 `ESLint` 作为代码检查工具，并使用 `Airbnb` 的检查规则。\r\n\r\nESLint：[https://github.com/eslint/eslint](https://github.com/eslint/eslint)\r\n\r\neslint-config-airbnb：[https://www.npmjs.com/package/eslint-config-airbnb](https://www.npmjs.com/package/eslint-config-airbnb)\r\n\r\n在 `package.json` 中可以看到，关于 `ESLint` 的包就是放在 `devDependencies` 底下的，因为它只是在开发的时候会使用到。 \r\n\r\n#### 使用\r\n\r\n- 在 `webpack` 配置中加载 `eslint-loader`：\r\n\r\n```javascript\r\nmodule: {\r\n  loaders: [\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /(node_modules)/,\r\n        loader: 'eslint-loader'\r\n      }\r\n    ]\r\n  }\r\n```\r\n\r\n- 创建 `.elintrc`文件：\r\n\r\n```javascript\r\n{\r\n  \"extends\": \"airbnb\",\r\n  \"env\":{\r\n    \"browser\": true\r\n  },\r\n  \"rules\":{}\r\n}\r\n```\r\n\r\n然后在运行 `webpack` 的时候，就会执行代码检查啦，看着一堆的 `warning` 、`error` 是不是很爽~\r\n\r\n这里有常见的ESLint规则：[http://eslint.cn/docs/rules/](http://eslint.cn/docs/rules/)\r\n\r\n### 数据源\r\n\r\n由于是为了练习 `React`，暂时就只考虑搭建一个静态页面，而且现在越来越多的大牛喜欢用 `Github Issues` 来写博客，也可以更好的地提供评论功能，所以我也想试试用 `Github Issues` 来作为博客的数据源。\r\n\r\nAPI在这：[https://developer.github.com/v3/issues/](https://developer.github.com/v3/issues/)\r\n\r\n我也没看完全部的API，就看了看怎么获取 `Issues` 列表。。\r\n\r\n```javascript\r\nhttps://api.github.com/repos/axuebin/react-blog/issues?creator=axuebin&labels=blog\r\n```\r\n\r\n通过控制参数 `creator` 和 `labels`，可以筛选出作为展示的 `Issues`。它会返回一个带有 `issue` 格式对象的数组。每一个 `issue` 有很多属性，我们可能不需要那么多，先了解了解底下这几种：\r\n\r\n```javascript\r\n// 为了方便，我把注释写在json中了。。\r\n[{\r\n  \"url\": ,  // issue 的 url\r\n  \"id\": ,  // issue id ， 是一个随机生成的不重复的数字串 \r\n  \"number\": ,  // issue number ， 根据创建 issue 的顺序从1开始累加\r\n  \"title\": ,  // issue 的标题\r\n  \"labels\": [], // issue 的所有 label，它是一个数组\r\n  \"created_at\": , // 创建 issue 的时间\r\n  \"updated_at\": , // 最后修改 issue 的时间\r\n  \"body\": , // issue 的内容\r\n}]\r\n```\r\n\r\n#### 异步请求数据\r\n\r\n项目中使用的异步请求数据的方法时 `fetch`。\r\n\r\n关于 `fetch` ：[https://segmentfault.com/a/1190000003810652](https://segmentfault.com/a/1190000003810652)\r\n\r\n使用起来很简单：\r\n\r\n```javascript\r\nfetch(url).then(response => response.json())\r\n      .then(json => console.log(json))\r\n      .catch(e => console.log(e));\r\n```\r\n\r\n### markdown 渲染\r\n\r\n在 `Github` 上查找关于如何在 `React` 实现 `markdown` 的渲染，查到了这两种库：\r\n\r\n- react-markdown：[https://github.com/rexxars/react-markdown](https://github.com/rexxars/react-markdown)\r\n- marked：[https://github.com/chjj/marked](https://github.com/chjj/marked)\r\n\r\n使用起来都很简单。\r\n\r\n如果是 `react-markdown`,只需要这样做：\r\n\r\n```javascript\r\nimport ReactMarkdown from 'react-markdown';\r\n\r\nconst input = '# This is a header\\n\\nAnd this is a paragraph';\r\nReactDOM.render(\r\n    <ReactMarkdown source={input} />,\r\n    document.getElementById('container')\r\n);\r\n```\r\n\r\n如果是`marked`，这样做：\r\n\r\n```javascript\r\nimport marked from 'marked';\r\n\r\nconst input = '# This is a header\\n\\nAnd this is a paragraph';\r\nconst output = marked(input);\r\n```\r\n\r\n这里有点不太一样，我们获取到了一个字符串 `output`，注意，是一个字符串，所以我们得将它插入到 `dom`中，在 `React` 中，我们可以这样做：\r\n\r\n```html\r\n<div dangerouslySetInnerHTML={{ __html: output }} />\r\n```\r\n\r\n由于我们的项目是基于 `React` 的，所以想着用 `react-markdown`会更好，而且由于安全问题 `React` 也不提倡直接往 `dom` 里插入字符串，然而在使用过程中发现，`react-markdown` 对表格的支持不友好，所以只好弃用，改用 `marked`。\r\n\r\n### 代码高亮\r\n\r\n代码高亮用的是`highlight.js`：[https://github.com/isagalaev/highlight.js](https://github.com/isagalaev/highlight.js)\r\n\r\n它和`marked`可以无缝衔接~\r\n\r\n只需要这样既可：\r\n\r\n```javascript\r\nimport hljs from 'highlight.js';\r\n\r\nmarked.setOptions({\r\n  highlight: code => hljs.highlightAuto(code).value,\r\n});\r\n```\r\n\r\n`highlight.js`是支持多种代码配色风格的，可以在`css`文件中进行切换：\r\n\r\n```css\r\n@import '~highlight.js/styles/atom-one-dark.css';\r\n```\r\n\r\n在这可以看到每种语言的高亮效果和配色风格：[https://highlightjs.org/](https://highlightjs.org/)\r\n\r\n## React\r\n\r\n### state 和 props 是什么\r\n\r\n可以看之前的一篇文章：[https://github.com/axuebin/react-blog/issues/8](https://github.com/axuebin/react-blog/issues/8)\r\n\r\n### 关于React组件的生命周期\r\n\r\n可以看之前的一篇文章：[https://github.com/axuebin/react-blog/issues/9](https://github.com/axuebin/react-blog/issues/9)\r\n\r\n## 前端路由\r\n\r\n项目中前端路由用的是 `React-Router V4`。\r\n\r\n官方文档：[https://reacttraining.com/react-router/web/guides/quick-start](https://reacttraining.com/react-router/web/guides/quick-start)\r\n\r\n中文文档：[http://reacttraining.cn/](http://reacttraining.cn/)\r\n\r\n### 基本使用\r\n\r\n```javascript\r\n<Link to=\"/blog\">Blog</Link>\r\n```\r\n\r\n```javascript\r\n<Router>\r\n  <Route exact path=\"/\" component={Home} />\r\n  <Route path=\"/blog\" component={Blog} />\r\n  <Route path=\"/demo\" component={Demo} />\r\n</Router>\r\n```\r\n\r\n注意：一定要在根目录的 `Route` 中声明 `exact`，要不然点击任何链接都无法跳转。\r\n\r\n### 2级目录跳转\r\n\r\n比如我现在要在博客页面上点击跳转，此时的 `url` 是 `localhost:8080/blog`,需要变成 `localhost:8080/blog/article`，可以这样做：\r\n\r\n```javascript\r\n<Route path={`${this.props.match.url}/article/:number`} component={Article} />\r\n```\r\n\r\n这样就可以跳转到 `localhost:8080/blog/article` 了，而且还传递了一个 `number` 参数，在 `article` 中可以通过 `this.props.params.number`获取。\r\n\r\n### HashRouter\r\n\r\n当我把项目托管到 `Github Page` 后，出现了这样一个问题。\r\n\r\n> 刷新页面出现 `Cannot GET /` 提示，路由未生效。\r\n\r\n通过了解，知道了原因是这样，并且可以解决：\r\n\r\n- 由于刷新之后，会根据URL对服务器发送请求，而不是处理路由，导致出现 `Cannot GET /` 错误。\r\n- 通过修改 `<Router>` → `<HashRouter>` 。\r\n- `<HashRouter>` 借助URL上的哈希值（hash）来实现路由。可以在不需要全屏刷新的情况下，达到切换页面的目的。\r\n\r\n### 路由跳转后不会自动回到顶部\r\n\r\n当前一个页面滚动到一定区域后，点击跳转后，页面虽然跳转了，但是会停留在滚动的区域，不会自动回到页面顶部。\r\n\r\n可以通过这样来解决：\r\n\r\n```javascript\r\ncomponentDidMount() {\r\n    this.node.scrollIntoView();\r\n}\r\n\r\nrender() {\r\n  return (\r\n    <div ref={node => this.node = node} ></div>\r\n  );\r\n}\r\n```\r\n\r\n## 状态管理\r\n\r\n项目中多次需要用到从 `Github Issues` 请求来的数据，因为之前就知道 `Redux` 这个东西的存在，虽然有点大材小用，为了学习还是将它用于项目的状态管理，只需要请求一次数据即可。\r\n\r\n官方文档：[http://redux.js.org/](http://redux.js.org/)\r\n\r\n中文文档：[http://cn.redux.js.org/](http://cn.redux.js.org/)\r\n\r\n简单的来说，每一次的修改状态都需要触发 `action` ，然而其实项目中我现在还没用到修改数据2333。。。\r\n\r\n关于状态管理这一块，由于还不是太了解，就不误人子弟了~\r\n\r\n## 主要组件\r\n\r\nReact是基于组件构建的，所以在搭建页面的开始，我们要先考虑一下我们需要一些什么样的组件，这些组件之间有什么关系，哪些组件是可以复用的等等等。\r\n\r\n### 首页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E9%A6%96%E9%A1%B5.gif)\r\n\r\n可以看到，我主要将首页分成了四个部分：\r\n\r\n- header：网站标题，副标题，导航栏\r\n- banner：about me ~，准备用自己的照片换个背景，但是还没有合适的照片\r\n- card area：暂时是三个卡片\r\n  - blog card：最近的几篇博文\r\n  - demo card：几个小demo类别\r\n  - me card：算是我放飞自我的地方吧 \r\n- footer：版权信息、备案信息、浏览量\r\n\r\n### 博客页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%8D%9A%E5%AE%A2%E9%A1%B5.gif)\r\n\r\n博客页就是很中规中矩的一个页面吧，这部分是整个项目中代码量最多的部分，包括以下几部分：\r\n\r\n- 文章列表组件\r\n- 翻页组件\r\n- 归档按钮组件\r\n- 类别组件\r\n- 标签组件\r\n\r\n#### 文章列表\r\n\r\n文章列表其实就是一个 `list`，里面有一个个的 `item`:\r\n\r\n```html\r\n<div class=\"archive-list\">\r\n  <div class=\"blog-article-item\">文章1</div>\r\n  <div class=\"blog-article-item\">文章2</div>\r\n<div>\r\n```\r\n\r\n对于每一个 `item`，其实是这样的：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E6%96%87%E7%AB%A0item.png)\r\n\r\n一个文章item组件它可能需要包括：\r\n\r\n- 文章标题\r\n- 文章发布的时间、类别、标签等\r\n- 文章摘要\r\n- ...\r\n\r\n如果用 `DOM` 来描述，它应该是这样的：\r\n\r\n```html\r\n<div class=\"blog-article-item\">\r\n  <div class=\"blog-article-item-title\">文章标题</div>\r\n  <div class=\"blog-article-item-time\">时间</div>\r\n  <div class=\"blog-article-item-label\">类别</div>\r\n  <div class=\"blog-article-item-label\">标签</div>\r\n  <div class=\"blog-article-item-desc\">摘要</div>\r\n</div>\r\n```\r\n\r\n所以，我们可以有很多个组件：\r\n\r\n- 文章列表组件 `<ArticleList />`\r\n- 文章item组件 `<ArticleItem />`\r\n- 类别标签组件 `<ArticleLabel />`\r\n\r\n它们可能是这样一个关系：\r\n\r\n```javascript\r\n<ArticleList>\r\n  <ArticleItem>\r\n    <ArticleTitle />\r\n    <ArticleTime />\r\n    <ArticleLabel />\r\n    <ArticleDesc />\r\n  </ArticleItem>\r\n  <ArticleItem></ArticleItem>\r\n  <ArticleItem></ArticleItem>\r\n</ArticleList>\r\n```\r\n\r\n#### 分页\r\n\r\n对于分页功能，传统的实现方法是在后端完成分页然后分批返回到前端的，比如可能会返回一段这样的数据：\r\n\r\n```javascript\r\n{\r\n  total:500,\r\n  page:1,\r\n  data:[]\r\n}\r\n```\r\n\r\n也就是后端会返回分好页的数据，含有表示总数据量的`total`、当前页数的`page`，以及属于该页的数据`data`。\r\n\r\n然而，我这个页面只是个静态页面，数据是放在Github Issues上的通过API获取的。（Github Issues的分页貌似不能自定义数量...），所以没法直接返回分好的数据，所以只能在前端强行分页~\r\n\r\n分页功能这一块我偷懒了...用的是 `antd` 的翻页组件 `<Pagination />`。\r\n\r\n官方文档：[https://ant.design/components/pagination-cn/](https://ant.design/components/pagination-cn/)\r\n\r\n文档很清晰，使用起来也特别简单。\r\n\r\n前端渲染的逻辑（有点蠢）：将数据存放到一个数组中，根据当前页数和每页显示条数来计算该显示的索引值，取出相应的数据即可。\r\n\r\n翻页组件中：\r\n\r\n```javascript\r\nconstructor() {\r\n  super();\r\n  this.onChangePage = this.onChangePage.bind(this);\r\n}\r\n\r\nonChangePage(pageNumber) {\r\n  this.props.handlePageChange(pageNumber);\r\n}\r\n\r\nrender() {\r\n  return (\r\n    <div className=\"blog-article-paging\">\r\n      <Pagination onChange={this.onChangePage} defaultPageSize={this.props.defaultPageSize} total={this.props.total} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n当页数发生改变后，会触发从父组件传进 `<ArticlePaging />` 的方法 `handlePageChange`，从而将页数传递到父组件中，然后传递到 `<ArticleList />` 中。 \r\n\r\n父组件中：\r\n\r\n```javascript\r\nhandlePageChange(pageNumber) {\r\n  this.setState({ currentPage: pageNumber });\r\n}\r\n\r\nrender() {\r\n  return (\r\n    <div className=\"archive-list-area\">\r\n      <ArticleList issues={this.props.issues} defaultPageSize={this.state.defaultPageSize} pageNumber={this.state.currentPage} />\r\n      <ArticlePaging handlePageChange={this.handlePageChange} total={this.props.issues.length} defaultPageSize={this.state.defaultPageSize} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n列表中：\r\n\r\n```javascript\r\nrender() {\r\n  const articlelist = [];\r\n  const issues = this.props.issues;\r\n  const currentPage = this.props.pageNumber;\r\n  const defaultPageSize = this.props.defaultPageSize;\r\n  const start = currentPage === 1 ? 0 : (currentPage - 1) * defaultPageSize;\r\n  const end = start + defaultPageSize < issues.length ? start + defaultPageSize : issues.length;\r\n  for (let i = start; i < end; i += 1) {\r\n    const item = issues[i];\r\n    articlelist.push(<ArticleItem />);\r\n  }\r\n}\r\n```\r\n\r\n#### label\r\n\r\n在 `Github Issues` 中，可以为一个 `issue` 添加很多个 `label`，我将这些对于博客内容有用的 `label` 分为三类，分别用不同颜色来表示。\r\n\r\n这里说明一下， `label` 创建后会随机生成一个 `id`，虽然说 `id` 是不重复的，但是文章的类别、标签会一直在增加，当新加一个 `label` 时，程序中可能也要进行对应的修改，当作区分 `label` 的标准可能就不太合适，所以我采用颜色来区分它们。\r\n\r\n- 表示这是一篇文章的blog：只有有 `blog` 的 `issue` 才能显示在页面上，过滤 `bug` 、`help` 等\r\n- 表示文章类别的：用来表示文章的类别，比如“前端”、“摄影”等\r\n- 表示文章标签的：用来表示文章的标签，比如“JavaScript”、“React”等\r\n\r\n即使有新的 `label` ，也只要根据颜色区分是属于哪一类就好了。\r\n\r\n##### 类别\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E7%B1%BB%E5%88%AB.gif)\r\n\r\n在这里的思路主要就是：遍历所有 `issues`，然后再遍历每个 `issue`的 `labels`，找出属于类别的 `label`，然后计数。\r\n\r\n```javascript\r\nconst categoryList = [];\r\nconst categoryHash = {};\r\nfor (let i = 0; i < issues.length; i += 1) {\r\n  const labels = issues[i].labels;\r\n  for (let j = 0; j < labels.length; j += 1) {\r\n    if (labels[j].color === COLOR_LABEL_CATEGORY) {\r\n      const category = labels[j].name;\r\n      if (categoryHash[category] === undefined) {\r\n        categoryHash[category] = true;\r\n        const categoryTemp = { category, sum: 1 };\r\n        categoryList.push(categoryTemp);\r\n      } else {\r\n        for (let k = 0; k < categoryList.length; k += 1) {\r\n          if (categoryList[k].category === category) {\r\n            categoryList[k].sum += 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n这样实现得要经历三次循环，复杂度有点高，感觉有点蠢，有待改进，如果有更好的方法，请多多指教~\r\n\r\n##### 标签\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E6%A0%87%E7%AD%BE.gif)\r\n\r\n这里的思路和类别的思路基本一样，只不过不同的显示方式而已。\r\n\r\n本来这里是想通过字体大小来体现每个标签的权重，后来觉得可能对于我来说，暂时只有那几个标签会很频繁，其它标签可能会很少，用字体大小来区分就没有什么意义，还是改成排序的方式。\r\n\r\n### 文章页\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E6%96%87%E7%AB%A0%E9%A1%B5.gif)\r\n\r\n文章页主要分为两部分：\r\n\r\n- 文章内容区域：显示文章内容，显示在页面的主体区域\r\n- 章节目录：文章的章节目录，显示在文章的右侧区域\r\n\r\n#### 文章内容\r\n\r\n有两种方式获取文章具体内容：\r\n\r\n- 从之前已经请求过的数组中去遍历查找所需的文章内容\r\n- 通过 `issue number` 重新发一次请求直接获取内容\r\n\r\n最后我选择了后者。\r\n\r\n文章是用 `markdown` 语法写的，所以要先转成 `html` 然后插入页面中，这里用了一个 `React` 不提倡的属性：`dangerouslySetInnerHTML`。 \r\n\r\n除了渲染`markdown`，我们还得对文章中的代码进行高亮显示，还有就是定制文章中不同标签的样式。\r\n\r\n#### 章节目录\r\n\r\n首先，这里有一个 `issue`，希望大家可以给一些建议~\r\n\r\n文章内容是通过 `markdown` 渲染后插入 `dom` 中的，由于 `React` 不建议通过 `document.getElementById` 的形式获取 `dom` 元素，所以只能想办法通过字符串匹配的方式获取文章的各个章节标题。\r\n\r\n由于我不太熟悉正则表达式，曾经还在sf上咨询过，就采用了其中一个答案：\r\n\r\n```javascript\r\nconst issues = content;\r\nconst menu = [];\r\nconst patt = /(#+)\\s+?(.+)/g;\r\nlet result = null;\r\nwhile ((result = patt.exec(issues))) {\r\n  menu.push({ level: result[1].length, title: result[2] });\r\n}\r\n```\r\n\r\n这样可以获取到所有的 `#` 的字符串，也就是 `markdown` 中的标题， `result[1].length` 表示有几个 `#`，其实就是几级标题的意思，`title` 就是标题内容了。\r\n\r\n这里还有一个问题，本来通过 `<a target=\"\" />` 的方式可以实现点击跳转，但是现在渲染出来的 `html` 中对于每一个标题没有独一无二的标识。。。\r\n\r\n### 归档页\r\n\r\n按年份归档：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%BD%92%E6%A1%A31.png)\r\n\r\n按类别归档：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%BD%92%E6%A1%A3.png)\r\n\r\n按标签归档：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/article%E5%BD%92%E6%A1%A32.png)\r\n\r\n## 问题\r\n\r\n基本功能是已经基本实现了，现在还存在着以下几个问题，也算是一个 `TodoList` 吧\r\n\r\n- 评论功能。拟利用 `Github Issues API` 实现评论，得实现 `Github` 授权登录\r\n- 回到顶部。拟利用 `antd` 的组件，但是 `state` 中 `visibility` 一直是 `false`\r\n- 首页渲染。现在打包完的js文件还是太大了，导致首页渲染太慢，这个是接下来工作的重点，也了解过关于这方面的优化：\r\n  - `webpack` 按需加载。这可能是目前最方便的方式\r\n  - 服务端渲染。这就麻烦了，但是好处也多，不仅解决渲染问题，还有利于SEO，所以也是 `todo` 之一\r\n- 响应式。现在的样式都是在PC端的，还未适配移动端。\r\n- 代码混乱，逻辑不对。这是我自己的问题，需要再修炼。\r\n"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/8",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/8/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/8/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/8/events",
    "html_url": "https://github.com/axuebin/articles/issues/8",
    "id": 265628000,
    "number": 8,
    "title": "ES6变量命名方式以及块级作用域",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720883997,
        "url": "https://api.github.com/repos/axuebin/articles/labels/ES6",
        "name": "ES6",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-16T02:14:05Z",
    "updated_at": "2017-10-20T10:55:03Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "之前看《深入理解es6》的笔记。。。\r\n\r\n----\r\n\r\n## var声明及变量提升机制\r\n\r\n在ES6之前，在函数作用域中或者全局作用域中通过`var`关键字来声明变量，无论是在代码的哪个位置，这条声明语句都会提到最顶部来执行，这就是变量声明提升。\r\n\r\n注意：**只是声明提升，初始化并没有提升。**\r\n\r\n看一个例子：\r\n\r\n```javascript\r\nfunction getStudent(name){\r\n  if(name){\r\n    var age=25;\r\n  }else{\r\n    console.log(\"name不存在\");      \r\n  }\r\n  console.log(age); //undefined\r\n}\r\n```\r\n\r\n如果按照预想的代码的执行顺序，当`name`有值时才会创建变量`age`，可是执行代码发现，即使不传入`name`，判断语句外的输出语句并没有报错，而是输出`undefined`。\r\n\r\n这就是变量声明提升。\r\n\r\n## 块级声明\r\n\r\nES6前是没有块级作用域的，比如`{}`外可以访问内部的变量。\r\n\r\n### let声明\r\n\r\n- 声明变量\r\n- 作用域限制在当前代码块\r\n- 声明不会提升\r\n- 禁止重声明（同一作用域不行，可以覆盖外部同名变量）\r\n\r\n```javascript\r\nfunction getStudent(name){\r\n  if(name){\r\n    let age=25;\r\n    console.log(age); //25\r\n  }else{\r\n    console.log(\"name不存在\");      \r\n  }\r\n  console.log(age); //age is not defined\r\n}\r\n```\r\n\r\n和上文一样的代码，只是将`age`的命名关键字从`var`改成了`let`，在执行`getStudent()`和`getStudent(\"axuebin\")`时都会报错。\r\n\r\n原因：\r\n\r\n- 在if语句内部执行之后，`age`变量将立即被销毁\r\n- 如果`name`为空，则永远都不会创建`age`变量\r\n\r\n### const声明\r\n\r\n- 声明常量\r\n- 必须初始化\r\n- 不可更改\r\n- 作用域限制在当前代码块\r\n- 声明不会提升\r\n- 禁止重声明（同一作用域不行，可以覆盖外部同名变量）\r\n\r\n如果用`const`来声明对象，则**对象中**的值可以修改。\r\n\r\n### 临时死区（Temporal Dead Zone）\r\n\r\nJavaScript引擎在扫面代码发现声明变量时，遇到`var`则提升到作用域顶部，遇到`let`和`const`则放到TDZ中。当执行了变量声明语句后，TDZ中的变量才能正常访问。\r\n\r\n## 循环中的块作用域绑定\r\n\r\n我们经常使用for循环：\r\n\r\n```javascript\r\nfor(var i=0;i<10;i++){\r\n  console.log(i); //0,1,2,3,4,5,6,7,8,9\r\n}\r\nconsole.log(i) //10\r\n```\r\n\r\n发现了什么？\r\n\r\n在for循环执行后，我们仍然可以访问到变量`i`。\r\n\r\nSo easy ~ 把`var`换成`let`就解决了~\r\n\r\n```javascript\r\nfor(let i=0;i<10;i++){\r\n  console.log(i); //0,1,2,3,4,5,6,7,8,9\r\n}\r\nconsole.log(i) //i is not defined\r\n```\r\n\r\n还记得当初讲闭包时setTimeout循环各一秒输出i的那个例子吗~\r\n\r\n曾经熟悉的你 ~ \r\n\r\n```javascript\r\nfor(var i=0;i<10;i++){\r\n  setTimeout(function(){\r\n    console.log(i); //10,10,10.....\r\n  },1000)\r\n}\r\n```\r\n\r\n很显然，上面的代码输出了10次的10，`setTimeout`在执行了循环之后才执行，此时`i`已经是10了~\r\n\r\n之前，我们这样做 ~\r\n\r\n```javascript\r\nfor(var i=0;i<10;i++){\r\n  setTimeout((function(i){\r\n    console.log(i); //0,1,2,3,4,5,6,7,8,9\r\n  })(i),1000)\r\n}\r\n```\r\n\r\n现在，我们这样做 ~ 来看看把`var`改成`let`会怎样~\r\n\r\n```javascript\r\nfor(let i=0;i<10;i++){\r\n  setTimeout(function(){\r\n    console.log(i); //0,1,2,3,4,5,6,7,8,9\r\n  },1000)\r\n}\r\n```\r\n\r\nnice~\r\n\r\n## 全局块作用域绑定\r\n\r\n在全局作用域下声明的时\r\n\r\n- `var`会覆盖window对象中的属性\r\n- `let`和`const`会屏蔽，而不是覆盖，用`window.`还能访问到"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/7",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/7/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/7/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/7/events",
    "html_url": "https://github.com/axuebin/articles/issues/7",
    "id": 265627940,
    "number": 7,
    "title": "JavaScript基础心法——call apply bind",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-16T02:13:33Z",
    "updated_at": "2017-10-26T06:44:27Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "整理`call`、`apply`、`bind`这三个方法的的知识点。\r\n\r\n----\r\n\r\n之前[这篇文章](http://axuebin.com/blog/2017/09/19/javascript-this/)提到过`this`的各种情况，其中有一种情况就是通过`call`、`apply`、`bind`来将`this`绑定到指定的对象上。\r\n\r\n也就是说，这三个方法可以改变函数体内部`this`的指向。\r\n\r\n这三个方法有什么区别呢？分别适合应用在哪些场景中呢？\r\n\r\n先举个简单的栗子 ~ \r\n\r\n```javascript\r\nvar person = {\r\n  name: \"axuebin\",\r\n  age: 25\r\n};\r\nfunction say(job){\r\n  console.log(this.name+\":\"+this.age+\" \"+job);\r\n}\r\nsay.call(person,\"FE\"); // axuebin:25 FE\r\nsay.apply(person,[\"FE\"]); // axuebin:25 FE\r\nvar sayPerson = say.bind(person,\"FE\");\r\nsayPerson(); // axuebin:25 FE\r\n```\r\n\r\n对于对象`person`而言，并没有`say`这样一个方法，通过`call`/`apply`/`bind`就可以将外部的`say`方法用于这个对象中，其实就是将`say`内部的`this`指向`person`这个对象。\r\n\r\n## call\r\n\r\n`call`是属于所有`Function`的方法，也就是`Function.prototype.call`。\r\n\r\n> The call() method calls a function with a given this value and arguments provided individually.\r\n\r\n> call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。\r\n\r\n它的语法是这样的：\r\n\r\n```javascript\r\nfun.call(thisArg[,arg1[,arg2,…]]);\r\n```\r\n\r\n其中，`thisArg`就是`this`指向，`arg`是指定的参数。\r\n\r\n`call`的用处简而言之就是可以让call()中的对象调用当前对象所拥有的function。\r\n\r\n### ECMAScript规范\r\n\r\nECMAScript规范中是这样定义`call`的：\r\n\r\n当以`thisArg`和可选的`arg1`,`arg2`等等作为参数在一个`func`对象上调用`call`方法，采用如下步骤：\r\n\r\n1. 如果`IsCallable(func)`是`false`, 则抛出一个`TypeError`异常。\r\n2. 令`argList`为一个空列表。\r\n3. 如果调用这个方法的参数多余一个，则从`arg1`开始以从左到右的顺序将每个参数插入为`argList`的最后一个元素。\r\n4. 提供`thisArg`作为`this`值并以`argList`作为参数列表，调用`func`的`[[Call]]`内部方法，返回结果。\r\n\r\n`call`方法的`length`属性是1。\r\n\r\n在外面传入的`thisArg`值会修改并成为`this`值。`thisArg`是`undefined`或`null`时它会被替换成全局对象，所有其他值会被应用`ToObject`并将结果作为`this`值，这是第三版引入的更改。\r\n\r\n### 使用call调用函数并且指定this\r\n\r\n```javascript\r\nvar obj = {\r\n  a: 1\r\n}\r\nfunction foo(b, c){\r\n  this.b = b;\r\n  this.c = c;\r\n  console.log(this.a + this.b + this.c);\r\n}\r\nfoo.call(obj,2,3); // 6\r\n```\r\n\r\n### call实现继承\r\n\r\n在需要实现继承的子类构造函数中，可以通过`call`调用父类构造函数实现继承。\r\n\r\n```javascript\r\nfunction Person(name, age){\r\n  this.name = name;\r\n  this.age = age;\r\n  this.say = function(){\r\n    console.log(this.name + \":\" + this.age);\r\n  }\r\n}\r\nfunction Student(name, age, job){\r\n  Person.call(this, name ,age);\r\n  this.job = job;\r\n  this.say = function(){\r\n    console.log(this.name + \":\" + this.age + \" \" + this.job);\r\n  }\r\n}\r\nvar me = new Student(\"axuebin\",25,\"FE\");\r\nconsole.log(me.say()); // axuebin:25 FE\r\n```\r\n\r\n## apply\r\n\r\n`apply`也是属于所有`Function`的方法，也就是`Function.prototype.apply`。\r\n\r\n> The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object).\r\n\r\n> apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。\r\n\r\n它的语法是这样的：\r\n\r\n```javascript\r\nfun.apply(thisArg, [argsArray]);\r\n```\r\n\r\n其中，`thisArg`就是`this`指向，`argsArray`是指定的参数数组。\r\n\r\n通过语法就可以看出`call`和`apply`的在参数上的一个区别：\r\n\r\n- `call`的参数是一个列表，将每个参数一个个列出来\r\n- `apply`的参数是一个数组，将每个参数放到一个数组中\r\n\r\n### ECMAScript规范\r\n\r\n当以`thisArg`和`argArray`为参数在一个`func`对象上调用`apply`方法，采用如下步骤：\r\n\r\n1. 如果`IsCallable(func)`是`false`, 则抛出一个`TypeError`异常 .\r\n2. 如果`argArray`是`null`或`undefined`, 则\r\n  1. 返回提供`thisArg`作为`this`值并以空参数列表调用`func`的`[[Call]]`内部方法的结果。\r\n3. 如果`Type(argArray)`不是`Object`, 则抛出一个`TypeError`异常 .\r\n4. 令`len`为以`\"length\"`作为参数调用`argArray`的`[[Get]]`内部方法的结果。\r\n5. 令`n`为`ToUint32(len)`.\r\n6. 令`argList`为一个空列表 .\r\n7. 令`index`为0.\r\n8. 只要`index`<`n`就重复\r\n  1. 令`indexName`为`ToString(index)`.\r\n  2. 令`nextArg`为以`indexName`作为参数调用`argArray`的`[[Get]]`内部方法的结果。\r\n  3. 将`nextArg`作为最后一个元素插入到`argList`里。\r\n  4. 设定`index`为`index + 1`.\r\n9. 提供`thisArg`作为`this`值并以`argList`作为参数列表，调用`func`的`[[Call]]`内部方法，返回结果。\r\n\r\n`apply`方法的`length`属性是 2。\r\n\r\n在外面传入的`thisArg`值会修改并成为`this`值。`thisArg`是`undefined`或`null`时它会被替换成全局对象，所有其他值会被应用`ToObject`并将结果作为`this`值，这是第三版引入的更改。\r\n\r\n### 用法\r\n\r\n在用法上`apply`和`call`一样，就不说了。\r\n\r\n### 实现一个apply\r\n\r\n参考链接：[https://github.com/jawil/blog/issues/16](https://github.com/jawil/blog/issues/16)\r\n\r\n#### 第一步，绑定上下文\r\n\r\n```javascript\r\nFunction.prototype.myApply=function(context){\r\n  // 获取调用`myApply`的函数本身，用this获取\r\n  context.fn = this;\r\n  // 执行这个函数\r\n  context.fn();\r\n  // 从上下文中删除函数引用\r\n  delete context.fn;\r\n}\r\n\r\nvar obj ={\r\n  name: \"xb\",\r\n  getName: function(){\r\n    console.log(this.name);\r\n  }\r\n}\r\n\r\nvar me = {\r\n  name: \"axuebin\"\r\n}\r\n\r\nobj.getName(); // xb \r\nobj.getName.myApply(me); // axuebin\r\n```\r\n\r\n确实成功地将`this`指向了`me`对象，而不是本身的`obj`对象。\r\n\r\n#### 第二步，给定参数\r\n\r\n上文已经提到`apply`需要接受一个参数数组，可以是一个类数组对象，还记得获取函数参数可以用`arguments`吗？\r\n\r\n```javascript\r\nFunction.prototype.myApply=function(context){\r\n  // 获取调用`myApply`的函数本身，用this获取\r\n  context.fn = this;\r\n  // 通过arguments获取参数\r\n  var args = arguments[1];\r\n  // 执行这个函数，用ES6的...运算符将arg展开\r\n  context.fn(...args);\r\n  // 从上下文中删除函数引用\r\n  delete context.fn;\r\n}\r\n\r\nvar obj ={\r\n  name: \"xb\",\r\n  getName: function(age){\r\n    console.log(this.name + \":\" + age);\r\n  }\r\n}\r\n\r\nvar me = {\r\n  name: \"axuebin\"\r\n}\r\n\r\nobj.getName(); // xb:undefined\r\nobj.getName.myApply(me,[25]); // axuebin:25\r\n```\r\n\r\n`context.fn(...arg)`是用了ES6的方法来将参数展开，如果看过[上面那个链接](https://github.com/jawil/blog/issues/16)，就知道这里不通过`...`运算符也是可以的。\r\n\r\n原博主通过拼接字符串，然后用`eval`执行的方式将参数传进`context.fn`中：\r\n\r\n```javascript\r\nfor (var i = 0; i < args.length; i++) {\r\n  fnStr += i == args.length - 1 ? args[i] : args[i] + ',';\r\n}\r\nfnStr += ')';//得到\"context.fn(arg1,arg2,arg3...)\"这个字符串在，最后用eval执行\r\neval(fnStr); //还是eval强大\r\n```\r\n\r\n#### 第三步，当传入apply的this为null或者为空时\r\n\r\n我们知道，当`apply`的第一个参数，也就是`this`的指向为`null`时，`this`会指向`window`。知道了这个，就简单了~\r\n\r\n```javascript\r\nFunction.prototype.myApply=function(context){\r\n  // 获取调用`myApply`的函数本身，用this获取，如果context不存在，则为window\r\n  var context = context || window;\r\n  context.fn = this;\r\n  //获取传入的数组参数\r\n  var args = arguments[1];\r\n  if (args == undefined) { //没有传入参数直接执行\r\n    // 执行这个函数\r\n    context.fn()\r\n  } else {\r\n    // 执行这个函数\r\n    context.fn(...args);\r\n  }\r\n  // 从上下文中删除函数引用\r\n  delete context.fn;\r\n}\r\n\r\nvar obj ={\r\n  name: \"xb\",\r\n  getName: function(age){\r\n    console.log(this.name + \":\" + age);\r\n  }\r\n}\r\n\r\nvar name = \"window.name\";\r\n\r\nvar me = {\r\n  name: \"axuebin\"\r\n}\r\n\r\nobj.getName(); // xb:25\r\nobj.getName.myApply(); // window.name:undefined\r\nobj.getName.myApply(null, [25]); // window.name:25\r\nobj.getName.myApply(me, [25]); // axuebin:25\r\n```\r\n\r\n#### 第四步 保证fn函数的唯一性\r\n\r\nES6中新增了一种基础数据类型`Symbol`。\r\n\r\n```javascript\r\nconst name = Symbol();\r\nconst age = Symbol();\r\nconsole.log(name === age); // false\r\n\r\nconst obj = {\r\n  [name]: \"axuebin\",\r\n  [age]: 25\r\n}\r\n\r\nconsole.log(obj); // {Symbol(): \"axuebin\", Symbol(): 25}\r\nconsole.log(obj[name]); // axuebin\r\n```\r\n\r\n所以我们可以通过`Symbol`来创建一个属性名。\r\n\r\n```javascript\r\nvar fn = Symbol();\r\ncontext[fn] = this;\r\n```\r\n\r\n#### 完整的apply\r\n\r\n```javascript\r\nFunction.prototype.myApply=function(context){\r\n  // 获取调用`myApply`的函数本身，用this获取，如果context不存在，则为window\r\n  var context = context || window;\r\n  var fn = Symbol();\r\n  context[fn] = this;\r\n  //获取传入的数组参数\r\n  var args = arguments[1];\r\n  if (args == undefined) { //没有传入参数直接执行\r\n    // 执行这个函数\r\n    context[fn]()\r\n  } else {\r\n    // 执行这个函数\r\n    context[fn](...args);\r\n  }\r\n  // 从上下文中删除函数引用\r\n  delete context.fn;\r\n}\r\n```\r\n\r\n这样就是一个完整的`apply`了，我们来测试一下：\r\n\r\n```javascript\r\nvar obj ={\r\n  name: \"xb\",\r\n  getName: function(age){\r\n    console.log(this.name + \":\" + age);\r\n  }\r\n}\r\n\r\nvar name = \"window.name\";\r\n\r\nvar me = {\r\n  name: \"axuebin\"\r\n}\r\n\r\nobj.getName(); // xb:25\r\nobj.getName.myApply(); // window.name:undefined\r\nobj.getName.myApply(null, [25]); // window.name:25\r\nobj.getName.myApply(me, [25]); // axuebin:25\r\n```\r\n\r\nok 没啥毛病 ~ \r\n\r\n再次感谢[1024大佬](https://github.com/jawil/blog/issues/16) ~\r\n\r\n## bind\r\n\r\n> The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.\r\n\r\n> bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。\r\n\r\n语法：\r\n\r\n```javascript\r\nfun.bind(thisArg[, arg1[, arg2[, ...]]])\r\n```\r\n\r\n其中，`thisArg`就是`this`指向，`arg`是指定的参数。\r\n\r\n可以看出，`bind`会创建一个新函数（称之为绑定函数），原函数的一个拷贝，也就是说不会像`call`和`apply`那样立即执行。\r\n\r\n当这个绑定函数被调用时，它的`this`值传递给`bind`的一个参数，执行的参数是传入`bind`的其它参数和执行绑定函数时传入的参数。\r\n\r\n### 用法\r\n\r\n当我们执行下面的代码时，我们希望可以正确地输出`name`，然后现实是残酷的\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.say = function(){\r\n    setTimeout(function(){\r\n      console.log(\"hello \" + this.name);\r\n    },1000)\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nperson.say(); //hello undefined\r\n```\r\n\r\n\r\n这里`this`运行时是指向`window`的，所以`this.name`是`undefined`，为什么会这样呢？看看MDN的解释：\r\n\r\n> 由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window。 \r\n\r\n有一个常见的方法可以使得正确的输出：\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.say = function(){\r\n    var self = this;\r\n    setTimeout(function(){\r\n      console.log(\"hello \" + self.name);\r\n    },1000)\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nperson.say(); //hello axuebin\r\n```\r\n\r\n没错，这里我们就可以用到`bind`了：\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.say = function(){\r\n    setTimeout(function(){\r\n      console.log(\"hello \" + this.name);\r\n    }.bind(this),1000)\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nperson.say(); //hello axuebin\r\n```\r\n\r\n### MDN的Polyfill\r\n\r\n```javascript\r\nFunction.prototype.bind = function (oThis) {\r\n  var aArgs = Array.prototype.slice.call(arguments, 1)；\r\n  var fToBind = this；\r\n  var fNOP = function () {}；\r\n  var fBound = function () {\r\n    fBound.prototype = this instanceof fNOP ? new fNOP() : fBound.prototype；\r\n    return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs )\r\n  }   \r\n  if( this.prototype ) {\r\n    fNOP.prototype = this.prototype；\r\n  }\r\n  return fBound；\r\n}\r\n```\r\n\r\n## 总结\r\n\r\n- 三者都是用来改变函数的`this`指向\r\n- 三者的第一个参数都是`this`指向的对象\r\n- `bind`是返回一个绑定函数可稍后执行，`call`、`apply`是立即调用\r\n- 三者都可以给定参数传递\r\n- `call`给定参数需要将参数全部列出，`apply`给定参数数组\r\n\r\n## 感谢\r\n\r\n[不用call和apply方法模拟实现ES5的bind方法](https://github.com/jawil/blog/issues/16)\r\n\r\n[深入浅出妙用 Javascript 中 apply、call、bind](http://web.jobbole.com/83642/)\r\n\r\n[回味JS基础:call apply 与 bind](https://juejin.im/post/57dc97f35bbb50005e5b39bd)"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/6",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/6/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/6/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/6/events",
    "html_url": "https://github.com/axuebin/articles/issues/6",
    "id": 265627894,
    "number": 6,
    "title": "JavaScript基础心法——this",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-16T02:13:10Z",
    "updated_at": "2017-10-26T06:44:33Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "看看这个有着深不可测的魔力的`this`到底是个什么玩意儿 ~\r\n\r\n----\r\n\r\n## 什么是this\r\n\r\n在传统面向对象的语言中，比如Java，`this`关键字用来表示当前对象本身，或当前对象的一个实例，通过`this`关键字可以获得当前对象的属性和调用方法。\r\n\r\n在JavaScript中，`this`似乎表现地略有不同，这也是让人“讨厌”的地方~\r\n\r\nECMAScript规范中这样写：\r\n\r\n> this 关键字执行为当前执行环境的 ThisBinding。\r\n\r\nMDN上这样写：\r\n\r\n> In most cases, the value of this is determined by how a function is called.\r\n> 在绝大多数情况下，函数的调用方式决定了this的值。\r\n\r\n可以这样理解，在JavaScript中，`this`的指向是调用时决定的，而不是创建时决定的，这就会导致`this`的指向会让人迷惑，简单来说，`this`具有运行期绑定的特性。\r\n\r\n参考资料：[this - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this \"this - JavaScript | MDN\")\r\n\r\n来看看不同的情况五花八门的`this`吧~\r\n\r\n## 调用位置\r\n\r\n首先需要理解调用位置，调用位置就是函数在代码中被调用的位置，而不是声明的位置。\r\n\r\n通过分析调用栈（到达当前执行位置所调用的所有函数）可以找到调用位置。\r\n\r\n```javascript\r\nfunction baz(){\r\n  console.log(\"baz\");\r\n  bar();\r\n}\r\nfunction bar(){\r\n  console.log(\"bar\");\r\n  foo();\r\n}\r\nfunction foo(){\r\n  console.log(\"foo\");\r\n}\r\nbaz();\r\n```\r\n\r\n当我们调用`baz()`时，它会以此调用`baz()`→`bar()`→`foo()`。\r\n\r\n对于`foo()`：调用位置是在`bar()`中。\r\n对于`bar()`：调用位置是在`baz()`中。\r\n而对于`baz()`：调用位置是全局作用域中。\r\n\r\n可以看出，调用位置应该是当前正在执行的函数的前一个调用中。\r\n\r\n## 全局上下文\r\n\r\n在全局执行上下文中`this`都指代全局对象。\r\n\r\n- `this`等价于`window`对象\r\n- `var` === `this.` === `winodw.`\r\n\r\n```javascript\r\nconsole.log(window === this); // true\r\nvar a = 1;\r\nthis.b = 2;\r\nwindow.c = 3;\r\nconsole.log(a + b + c); // 6\r\n```\r\n\r\n在浏览器里面`this`等价于`window`对象，如果你声明一些全局变量，这些变量都会作为this的属性。\r\n\r\n## 函数上下文\r\n\r\n在函数内部，`this`的值取决于函数被调用的方式。\r\n\r\n### 直接调用\r\n\r\n**`this`指向全局变量。**\r\n\r\n```javascript\r\nfunction foo(){\r\n  return this;\r\n}\r\nconsole.log(foo() === window); // true\r\n```\r\n\r\n### call()、apply()\r\n\r\n**`this`指向绑定的对象上。**\r\n\r\n```javascript\r\nvar person = {\r\n  name: \"axuebin\",\r\n  age: 25\r\n};\r\nfunction say(job){\r\n  console.log(this.name+\":\"+this.age+\" \"+job);\r\n}\r\nsay.call(person,\"FE\"); // axuebin:25\r\nsay.apply(person,[\"FE\"]); // axuebin:25\r\n```\r\n\r\n可以看到，定义了一个`say`函数是用来输出`name`、`age`和`job`，其中本身没有`name`和`age`属性，我们将这个函数绑定到`person`这个对象上，输出了本属于`person`的属性，说明此时`this`是指向对象`person`的。\r\n\r\n如果传入一个原始值（字符串、布尔或数字类型）来当做`this`的绑定对象， 这个原始值会被转换成它的对象形式（`new String()`），这通常被称为“装箱”。\r\n\r\n`call`和`apply`从`this`的绑定角度上来说是一样的，唯一不同的是它们的第二个参数。\r\n\r\n### bind()\r\n\r\n**`this`将永久地被绑定到了`bind`的第一个参数。**\r\n\r\n`bind`和`call`、`apply`有些相似。\r\n\r\n```javascript\r\nvar person = {\r\n  name: \"axuebin\",\r\n  age: 25\r\n};\r\nfunction say(){\r\n  console.log(this.name+\":\"+this.age);\r\n}\r\nvar f = say.bind(person);\r\nconsole.log(f());\r\n```\r\n\r\n### 箭头函数\r\n\r\n**所有的箭头函数都没有自己的`this`，都指向外层。**\r\n\r\n关于箭头函数的争论一直都在，可以看看下面的几个链接：\r\n\r\n[ES6 箭头函数中的 this？你可能想多了（翻译）](http://www.cnblogs.com/vajoy/p/4902935.html)\r\n\r\n[关于箭头函数this的理解几乎完全是错误的 #150](https://github.com/ruanyf/es6tutorial/issues/150)\r\n\r\nMDN中对于箭头函数这一部分是这样描述的：\r\n\r\n> An arrow function does not create its own this, the this value of the enclosing execution context is used.\r\n> 箭头函数会捕获其所在上下文的this值，作为自己的this值。\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.say = () => {\r\n    var name = \"xb\";\r\n    return this.name;\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nconsole.log(person.say()); // axuebin\r\n```\r\n\r\n箭头函数常用语回调函数中，例如定时器中：\r\n\r\n```javascript\r\nfunction foo() {  \r\n  setTimeout(()=>{\r\n    console.log(this.a);\r\n  },100)\r\n}\r\nvar obj = {\r\n  a: 2\r\n}\r\nfoo.call(obj);\r\n```\r\n\r\n附上MDN关于箭头函数`this`的解释：\r\n\r\n[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#不绑定_this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#不绑定_this)\r\n\r\n### 作为对象的一个方法\r\n\r\n**`this`指向调用函数的对象。**\r\n\r\n```javascript\r\nvar person = {\r\n  name: \"axuebin\",\r\n  getName: function(){\r\n    return this.name;\r\n  }\r\n}\r\nconsole.log(person.getName()); // axuebin\r\n```\r\n\r\n这里有一个需要注意的地方。。。\r\n\r\n```javascript\r\nvar name = \"xb\";\r\nvar person = {\r\n  name: \"axuebin\",\r\n  getName: function(){\r\n    return this.name;\r\n  }\r\n}\r\nvar getName = person.getName;\r\nconsole.log(getName()); // xb\r\n```\r\n\r\n发现`this`又指向全局变量了，这是为什么呢？\r\n\r\n还是那句话，`this`的指向得看函数调用时。 \r\n\r\n### 作为一个构造函数\r\n\r\n**`this`被绑定到正在构造的新对象。**\r\n\r\n通过构造函数创建一个对象其实执行这样几个步骤：\r\n\r\n1. 创建新对象\r\n2. 将this指向这个对象\r\n3. 给对象赋值（属性、方法）\r\n4. 返回this\r\n\r\n所以`this`就是指向创建的这个对象上。\r\n\r\n```javascript\r\nfunction Person(name){\r\n  this.name = name;\r\n  this.age = 25;\r\n  this.say = function(){\r\n    console.log(this.name + \":\" + this.age);\r\n  }\r\n}\r\nvar person = new Person(\"axuebin\");\r\nconsole.log(person.name); // axuebin\r\nperson.say(); // axuebin:25\r\n```\r\n\r\n### 作为一个DOM事件处理函数\r\n\r\n**`this`指向触发事件的元素，也就是始事件处理程序所绑定到的DOM节点。**\r\n\r\n```javascript\r\nvar ele = document.getElementById(\"id\");\r\nele.addEventListener(\"click\",function(e){\r\n  console.log(this);\r\n  console.log(this === e.target); // true\r\n})\r\n```\r\n\r\n### HTML标签内联事件处理函数\r\n\r\n**`this`指向所在的DOM元素**\r\n\r\n```html\r\n<button onclick=\"console.log(this);\">Click Me</button>\r\n```\r\n\r\n### jQuery的this\r\n\r\n**在许多情况下JQuery的`this`都指向DOM元素节点。**\r\n\r\n```javascript\r\n$(\".btn\").on(\"click\",function(){\r\n  console.log(this); \r\n});\r\n```\r\n\r\n## 总结\r\n\r\n如果要判断一个函数的`this`绑定，就需要找到这个函数的直接调用位置。然后可以顺序按照下面四条规则来判断`this`的绑定对象：\r\n\r\n1. 由`new`调用：绑定到新创建的对象\r\n2. 由`call`或`apply`、`bind`调用：绑定到指定的对象\r\n3. 由上下文对象调用：绑定到上下文对象\r\n4. 默认：全局对象\r\n\r\n注意：箭头函数不使用上面的绑定规则，根据外层作用域来决定`this`，继承外层函数调用的`this`绑定。"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/5",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/5/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/5/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/5/events",
    "html_url": "https://github.com/axuebin/articles/issues/5",
    "id": 265627820,
    "number": 5,
    "title": "React的生命周期到底是怎么一回事？",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720883997,
        "url": "https://api.github.com/repos/axuebin/articles/labels/ES6",
        "name": "ES6",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884233,
        "url": "https://api.github.com/repos/axuebin/articles/labels/React",
        "name": "React",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-16T02:12:31Z",
    "updated_at": "2017-10-20T10:54:39Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "尽量全面详细的整理一下React的生命周期中的知识点。\r\n\r\n----\r\n\r\n## 组件\r\n\r\n组件是独立的封装的可以复用的一个小部件，它是React的核心思想之一。通过划分组件，可以将一个页面划分成独立的多个可复用的组件，各个组件通过嵌套、组合形成一个完整的页面。\r\n\r\n在React中，组件基本由三个部分组成：属性（props）、状态（state）以及生命周期方法。可以将组件简单地看作一个“状态机”，根据不同的`state`和`props`呈现不同的UI，通过与用户的交互实现不同的状态，然后重新渲染组件，UI可以跟随数据变化而变化。\r\n\r\n### 创建组件\r\n\r\n组件常分为两种：`Class Component`和`Functional Component`。\r\n\r\n#### 无状态组件\r\n\r\n`Functional Component`也称为无状态组件，它多用于纯展示组件，这种组件只负责根据传入的`props`来渲染组件，而不涉及`state`状态管理。\r\n\r\n> 在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。\r\n\r\n无状态组件可以通过函数形式或者ES6的箭头函数来创建：\r\n\r\n```javascript\r\n// 函数\r\nfunction HelloFunctional(props){\r\n  return <div>hello {props.name}</div>;\r\n}\r\n\r\n// ES6箭头函数\r\nconst HelloFunctional = (props) => (<div>hello {props.name}</div>);\r\n```\r\n\r\n无状态组件有以下几个特点：\r\n\r\n1. 代码可读性更好\r\n2. 组件不会被实例化，渲染性能提升\r\n3. 无生命周期方法\r\n4. 只能输入`props`，同样的输入一定会有同样的输出\r\n\r\n所以，在项目中如果不需要进行状态管理，应该尽量写成无状态组件的形式。\r\n\r\n#### 有状态组件\r\n\r\n现在主流的创建有状态组件的形式是通过ES6的Class来创建，取代`React.createClass`：\r\n\r\n```javascript\r\nClass HelloClass extends React.Component{\r\n  constructor(){\r\n    this.state = {\r\n      name:'axuebin'\r\n    }\r\n  }\r\n  render(){\r\n    return (<div>hello {this.state.name}</div>);\r\n  }\r\n}\r\n```\r\n\r\n这是最简洁的一个组件，它需要使用到内部状态`state`。\r\n\r\n**当组件需要使用内部状态时或者需要使用生命周期方法时就需要使用有状态组件。**\r\n\r\n## 组件的生命周期\r\n\r\nReact组件的生命周期可以分为挂载、渲染和卸载这几个阶段，当渲染后的组件更新后，会重新渲染组件，直到卸载。先分阶段来看看每个阶段有哪些生命周期函数。\r\n\r\n### 挂载阶段（Mounting）\r\n\r\n属于这个阶段的生命周期函数有：\r\n\r\n1. constructor()\r\n2. componentWillMount()\r\n3. render()\r\n4. componentDidMount()\r\n\r\n#### constructor()\r\n\r\n```javascript\r\nconstructor() {\r\n  super();\r\n  this.state = {name: 'axuebin'};\r\n  this.handleClick = this.handleClick.bind(this); \r\n}\r\n```\r\n\r\n这个阶段就是组件的初始化，`constructor()`可以理解为组件的构造函数，从组件的类`class`实例化一个组件实例。这个函数是组件形成时就被调用的，是生命周期中最先执行的。\r\n\r\n在`constructor()`函数内，首先必须执行`super()`，否则`this.props`将是未定义，会引发异常。\r\n\r\n然后，如果有必要，可以进行：\r\n\r\n- `state`的初始化\r\n- 方法的绑定\r\n\r\n如果不需要这两步，可以直接省略`constructor`函数。\r\n\r\n#### componentWillMount()\r\n\r\n这个函数按照驼峰法的命名规则可以理解为“组件即将被挂载”，所以这个函数是组件首次渲染（render）前调用的。\r\n\r\n在每次页面加载、刷新时，或者某个组件第一次展现时都会调用这个函数。通常地，我们推荐使用`constructor()`来替代。\r\n\r\n**注意：在这个函数中，不可以调用`setState`来修改状态。**\r\n\r\n#### render()\r\n\r\n```javascript\r\nrender() {\r\n  return(\r\n    <div>hello {this.state.name} {this.props.age}</div>\r\n  )\r\n}\r\n```\r\n\r\n`render()`在生命周期中是必须的，是渲染组件用的。\r\n\r\n当这个函数被调用时，需要检查`this.props`和`this.state`并且返回一个元素（有且只有一个元素），这个元素可能是一个原生DOM元素，也有可能是另一个React组件。\r\n\r\n可以在`state`或`props`状态为空时试着返回一个`null`或者`false`来声明不想渲染任何东西。\r\n\r\n在这个函数中，不应该改变组件的状态，也就是不执行`this.setState`，需要保持`render()`函数的纯净。\r\n\r\n在这个函数中，可以对`props`进行调用并组合，但不可修改。\r\n\r\n#### componentDidMount()\r\n\r\n```javascript\r\ncomponentDidMount() {\r\n  this.setState({name:'xb'});\r\n}\r\n```\r\n\r\n这个函数在组件加载渲染完成后立即调用，此时页面上已经渲染出真实的DOM了，可以在这个函数中访问到真实的DOM（可以通过`this.refs`来访问真实DOM）。\r\n\r\n在这个阶段，还可以做一件事，可以修改`state`了！！！\r\n\r\n而且，异步获取数据在这个阶段执行也是比较合理的，获取数据之后`setState`，然后重新渲染组件。\r\n\r\n### 更新阶段（Updating）\r\n\r\n属性或状态的改变会触发一次更新。当一个组件在被重新渲染时，这些方法将会被调用：\r\n\r\n1. componentWillReceiveProps()\r\n2. shouldComponentUpdate()\r\n3. componentWillUpdate()\r\n4. render()\r\n5. componentDidUpdate()\r\n\r\n#### componentWillReceiveProps()\r\n\r\n已加载的组件在`props`发生变化时调用，若需要更新状态，可能需要对比`this.props`和`nextProps`然后在该方法中使用`this.setState`来处理状态的改变。\r\n\r\n需要注意的是，有些情况下，即使`props`未改变也会触发该函数，所以一定要先比较`this.props`和`nextProps`再做操作。\r\n\r\n该函数只监听`props`的改变，`this.setState`不会触发这个函数。\r\n\r\n```javascript\r\ncomponentWillReceiveProps(nextProps){\r\n  if (this.props.color !== nextProps.color){\r\n    this.setState({});\r\n  }\r\n}\r\n```\r\n\r\n#### shouldComponentUpdate()\r\n\r\n这个函数只返回`true`或`false`，表示组件是否需要更新（重新渲染）。\r\n\r\n1. 返回`true`就是紧接着以下的生命周期函数；\r\n2. 返回`false`表示组件不需要重新渲染，不再执行任何生命周期函数（包括render）。\r\n\r\n这个函数使用需谨慎，react官方文档中说道，在未来这个函数返回`false`可能仍然使得组件重新渲染。\r\n\r\n#### componentWillUpdate()\r\n\r\n这个函数看名字就和`componentWillMount`很像，它执行的阶段也很像。在接收到新的`props`或者`state`之后，这个函数就会在`render`前被调用。\r\n\r\n同样的，在这个函数中不能使用`this.setState()`。如果需要更新状态，请在`componentWillReceiveProps`中调用`this.setState()`。\r\n\r\n#### render()\r\n\r\n又是一次的`render`。这和挂载阶段的`render`有什么区别呢？\r\n\r\n在函数的性质上来说，两者毫无区别，只不过是在生命周期的不同阶段的调用。\r\n\r\n- 前一个`render`是在组件第一次加载时调用的，也就是初次渲染，可以理解为`mount`；\r\n- 后一个`render`是除去第一次之后调用的，也就是再渲染，`re-render`；\r\n\r\n#### componentDidUpdate()\r\n\r\n同样地，这个方法是在组件`re-render`之后调用的，该方法不会在初始化的时候调用。和`componentDidMount`一样，在这个函数中可以使用`this.refs`获取真实DOM。\r\n\r\n还可以修改`state`哦，不过会导致组件再次`re-render`。\r\n\r\n### 卸载阶段（Unmounting）\r\n\r\n该方法将会在 component 从DOM中移除时调用\r\n\r\n- componentWillUnmount()\r\n\r\n#### componentWillUnmount()\r\n\r\n卸载阶段就很简单了，就这一个生命周期函数，在组件被卸载和销毁之前立刻调用。\r\n\r\n在这个函数中，应该处理任何必要的清理工作，比如销毁定时器、取消网络请求、清除之前创建的相关DOM节点等。\r\n\r\n## 生命周期流程图\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/react-lifecycle%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/4",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/4/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/4/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/4/events",
    "html_url": "https://github.com/axuebin/articles/issues/4",
    "id": 265627756,
    "number": 4,
    "title": "React中state和props分别是什么？",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720883997,
        "url": "https://api.github.com/repos/axuebin/articles/labels/ES6",
        "name": "ES6",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884233,
        "url": "https://api.github.com/repos/axuebin/articles/labels/React",
        "name": "React",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-16T02:11:56Z",
    "updated_at": "2017-10-20T10:54:29Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "整理一下React中关于state和props的知识点。\r\n\r\n----\r\n\r\n在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在`props`和`state`中，这两个属性有啥子区别呢？\r\n\r\n## props\r\n\r\nReact的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。\r\n\r\n组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是`props`，所以可以把`props`理解为从外部传入组件内部的数据。由于React是单向数据流，所以`props`基本上也就是从服父级组件向子组件传递的数据。\r\n\r\n### 用法\r\n\r\n假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：`<ItemList/>`和`<Item/>`。\r\n\r\n先看看`<ItemList/>`\r\n\r\n```jsx\r\nimport Item from \"./item\";\r\nexport default class ItemList extends React.Component{\r\n  const itemList = data.map(item => <Item item=item />);\r\n  render(){\r\n    return (\r\n      {itemList}\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n列表的数据我们就暂时先假设是放在一个`data`变量中，然后通过`map`函数返回一个每一项都是`<Item item='数据'/>`的数组，也就是说这里其实包含了`data.length`个`<Item/>`组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。\r\n\r\n在`<Item />`中是这样的：\r\n\r\n```jsx\r\nexport default class Item extends React.Component{\r\n  render(){\r\n    return (\r\n      <li>{this.props.item}</li>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n在`render`函数中可以看出，组件内部是使用`this.props`来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个`item`属性，所以通过`this.props.item`来获取即可。\r\n\r\n### 只读性\r\n\r\n`props`经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的`props`是只读的，不可改变的。如果`props`在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的`props`传入组件中。\r\n\r\n### 默认参数\r\n\r\n在组件中，我们最好为`props`中的参数设置一个`defaultProps`，并且制定它的类型。比如，这样：\r\n\r\n```javascript\r\nItem.defaultProps = {\r\n  item: 'Hello Props',\r\n};\r\n\r\nItem.propTypes = {\r\n  item: PropTypes.string,\r\n};\r\n```\r\n\r\n关于`propTypes`，可以声明为以下几种类型：\r\n\r\n```javascript\r\noptionalArray: PropTypes.array,\r\noptionalBool: PropTypes.bool,\r\noptionalFunc: PropTypes.func,\r\noptionalNumber: PropTypes.number,\r\noptionalObject: PropTypes.object,\r\noptionalString: PropTypes.string,\r\noptionalSymbol: PropTypes.symbol,\r\n```\r\n\r\n注意，`bool`和`func`是简写。\r\n\r\n这些知识基础数据类型，还有一些复杂的，附上链接：\r\n\r\n[https://facebook.github.io/react/docs/typechecking-with-proptypes.html](https://facebook.github.io/react/docs/typechecking-with-proptypes.html)\r\n\r\n### 总结\r\n\r\n`props`是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的`props`来重新渲染子组件，否则子组件的`props`以及展现形式不会改变。\r\n\r\n## state\r\n\r\n`state`是什么呢？\r\n\r\n> State is similar to props, but it is private and fully controlled by the component.\r\n\r\n一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是`props`，而数据状态就是`state`。\r\n\r\n### 用法\r\n\r\n```javascript\r\nexport default class ItemList extends React.Component{\r\n  constructor(){\r\n    super();\r\n    this.state = {\r\n      itemList:'一些数据',\r\n    }\r\n  }\r\n  render(){\r\n    return (\r\n      {this.state.itemList}\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n首先，在组件初始化的时候，通过`this.state`给组件设定一个初始的`state`，在第一次`render`的时候就会用这个数据来渲染组件。\r\n\r\n### setState\r\n\r\n`state`不同于`props`的一点是，`state`是可以被改变的。不过，不可以直接通过`this.state=`的方式来修改，而需要通过`this.setState()`方法来修改`state`。\r\n\r\n比如，我们经常会通过异步操作来获取数据，我们需要在`didMount`阶段来执行异步操作：\r\n\r\n```javascript\r\ncomponentDidMount(){\r\n  fetch('url')\r\n    .then(response => response.json())\r\n    .then((data) => {\r\n      this.setState({itemList:item});  \r\n    }\r\n}\r\n```\r\n\r\n当数据获取完成后，通过`this.setState`来修改数据状态。\r\n\r\n当我们调用`this.setState`方法时，React会更新组件的数据状态`state`，并且重新调用`render`方法，也就是会对组件进行重新渲染。\r\n\r\n**注意：通过`this.state=`来初始化`state`，使用`this.setState`来修改`state`，`constructor`是唯一能够初始化的地方。**\r\n\r\n`setState`接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：\r\n\r\n```javascript\r\nexport default class ItemList extends React.Component{\r\n  constructor(){\r\n    super();\r\n    this.state = {\r\n      name:'axuebin',\r\n      age:25,\r\n    }\r\n  }\r\n  componentDidMount(){\r\n    this.setState({age:18})  \r\n  }\r\n}\r\n```\r\n\r\n在执行完`setState`之后的`state`应该是`{name:'axuebin',age:18}`。\r\n\r\n`setState`还可以接受第二个参数，它是一个函数，会在`setState`调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：\r\n\r\n```javascript\r\nthis.setState({\r\n  name:'xb'\r\n},()=>console.log('setState finished'))\r\n```\r\n\r\n### 总结\r\n\r\n`state`的主要作用是用于组件保存、控制以及修改自己的状态，它只能在`constructor`中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的`this.setState`来修改，修改`state`属性会导致组件的重新渲染。\r\n\r\n\r\n## 区别\r\n\r\n1. `state`是组件自己管理数据，控制自己的状态，可变；\r\n2. `props`是外部传入的数据参数，不可变；\r\n3. 没有`state`的叫做无状态组件，有`state`的叫做有状态组件；\r\n4. 多用`props`，少用`state`。也就是多写无状态组件。"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/3",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/3/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/3/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/3/events",
    "html_url": "https://github.com/axuebin/articles/issues/3",
    "id": 265627702,
    "number": 3,
    "title": "JavaScript基础心法——数据类型",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-16T02:11:30Z",
    "updated_at": "2017-10-26T06:44:38Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "一个很基础的知识点，JavaScript中基本数据类型和引用数据类型是如何存储的。\r\n\r\n----\r\n\r\n由于自己是野生程序员，在刚开始学习程序设计的时候没有在意内存这些基础知识，导致后来在提到“什么什么是存在栈中的，栈中只是存了一个引用”这样的话时总是一脸懵逼。。\r\n\r\n后来渐渐的了解了一些内存的知识，这部分还是非常有必要了解的。\r\n\r\n## 基本数据结构\r\n\r\n### 栈\r\n\r\n> 栈，只允许在一段进行插入或者删除操作的线性表，是一种先进后出的数据结构。\r\n\r\n### 堆\r\n\r\n> 堆是基于散列算法的数据结构。\r\n\r\n### 队列\r\n\r\n> 队列是一种先进先出（FIFO）的数据结构。\r\n\r\n## JavaScript中数据类型的存储\r\n\r\nJavaScript中将数据类型分为基本数据类型和引用数据类型，它们其中有一个区别就是存储的位置不同。\r\n\r\n### 基本数据类型\r\n\r\n我们都知道JavaScript中的基本数据类型有：\r\n\r\n- String\r\n- Number\r\n- Boolean\r\n- Undefined\r\n- Null\r\n- Symbol（暂时不管）\r\n\r\n基本数据类型都是一些简单的数据段，它们是存储在栈内存中。\r\n\r\n### 引用数据类型\r\n\r\nJavaScript中的引用数据类型有：\r\n\r\n- Array\r\n- Object\r\n\r\n引用数据类型是保存在堆内存中的，然后再栈内存中保存一个对堆内存中实际对象的引用。所以，JavaScript中对引用数据类型的操作都是操作对象的引用而不是实际的对象。\r\n\r\n可以理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的。\r\n\r\n### 图解\r\n\r\n现在，我们声明几个变量试试：\r\n\r\n```js\r\nvar name=\"axuebin\";\r\nvar age=25;\r\nvar job;\r\nvar arr=[1,2,3];\r\nvar obj={age:25};\r\n```\r\n\r\n可以通过下图来表示数据类型在内存中的存储情况：\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png)\r\n\r\n此时`name`,`age`,`job`三种基本数据类型是直接存在栈内存中的，而`arr`,`obj`在栈内存中只是存了一个地址来表示对堆内存中的引用。\r\n\r\n### 复制\r\n\r\n#### 基本数据类型\r\n\r\n对于基本数据类型，如果进行复制，系统会自动为新的变量在栈内存中分配一个新值，很容易理解。\r\n\r\n#### 引用数据类型\r\n\r\n如果对于数组、对象这样的引用数据类型而言，复制的时候就会有所区别了：\r\n\r\n系统也会自动为新的变量在栈内存中分配一个值，但这个值仅仅是一个地址。也就是说，复制出来的变量和原有的变量具有相同的地址值，指向堆内存中的同一个对象。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/JS%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%A4%8D%E5%88%B6.png)\r\n\r\n如果所示，执行了`var objCopy=obj`之后，`obj`和`objCopy`具有相同的地址值，执行堆内存中的同一个实际对象。\r\n\r\n这有什么不同呢？\r\n\r\n当我修改`obj`或`objCopy`时，都会引起另一个变量的改变。\r\n\r\n### 为什么？\r\n\r\n为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？\r\n\r\n1. 堆比栈大，栈比对速度快。\r\n2. 基础数据类型比较稳定，而且相对来说占用的内存小。\r\n3. 引用数据类型大小是动态的，而且是无限的。\r\n4. 堆内存是无序存储，可以根据引用直接获取。\r\n\r\n## 参考文章\r\n\r\n[http://www.jianshu.com/p/996671d4dcc4](http://www.jianshu.com/p/996671d4dcc4)\r\n[http://blog.sina.com.cn/s/blog_8ecde0fe0102vy6e.html](http://blog.sina.com.cn/s/blog_8ecde0fe0102vy6e.html)"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/2",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/2/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/2/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/2/events",
    "html_url": "https://github.com/axuebin/articles/issues/2",
    "id": 265627625,
    "number": 2,
    "title": "用React实现一个简易的TodoList",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720883997,
        "url": "https://api.github.com/repos/axuebin/articles/labels/ES6",
        "name": "ES6",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884233,
        "url": "https://api.github.com/repos/axuebin/articles/labels/React",
        "name": "React",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-16T02:10:49Z",
    "updated_at": "2017-10-20T10:54:10Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "初学React，撸一个TodoList熟悉熟悉基本语法，只有最简单最简单的功能。\r\n\r\n----\r\n\r\n![](http://i.imgur.com/tT18EpC.png)\r\n\r\n如上图所示，是一个最简单的TodoList的样子了，我们应该怎样把它拆成一个个的组件呢？\r\n\r\n在之前看来，可能就是这样一个HTML结构：\r\n\r\n```html\r\n<div>\r\n  <h1></h1>\r\n  <div>\r\n    <ul>\r\n      <li></li>\r\n      <li></li>\r\n      <li></li>\r\n    </ul>\r\n  </div>\r\n  <div>\r\n    <input/>\r\n    <button>保存</button>\r\n  </div>\r\n</div>\r\n```\r\n\r\n> React的核心思想是：封装组件。\r\n\r\n我们也可以按照这个思路来进行组件设计\r\n\r\n## 组件设计\r\n\r\n![](http://i.imgur.com/bp6NaWf.png)\r\n\r\n从小到大，从内到外 ~ \r\n\r\n我是这样进行设计的。\r\n\r\n除去按钮，input这些之外，`<li></li>`是HTML中最小的元素，我们可以先每一个`<li></li>`当成是一个最小的组件，也就是图中橙色框的部分，它对应着每一条内容，我们先把它命名为`TodoItem`吧。\r\n\r\n`<li></li>`的父级元素是`<ul></ul>`，那就把它看作一个组件呗，图中位于上方的蓝色部分，命名为`TodoList`。\r\n\r\n恩，此时Todo内容的展示组件已经是够的了，我们再来加一个添加Todo内容的组件`AddTodoItem`吧，命名貌似有点丑- -，图中位于下方的蓝色部分。\r\n\r\n最后就是最外层的红色部分了，它就是整个app的主体部分，包含着其它小组件，命名为`TodoBox`。\r\n\r\nok，暂时就这几个小组件 ~ \r\n\r\n然我们开始愉快的撸代码吧 ~\r\n\r\n## 代码部分\r\n\r\n### Index\r\n\r\n先看看入口程序，很简单。\r\n\r\n```javascript\r\nvar React = require('react');\r\nvar ReactDOM = require('react-dom');\r\nimport TodoBox from './components/todobox';\r\nimport './../css/index.css';\r\n\r\nexport default class Index extends React.Component {\r\n  constructor(){\r\n    super();\r\n  };\r\n  render() {\r\n    return (\r\n        <TodoBox />\r\n    );\r\n  }\r\n}\r\n\r\nReactDOM.render(<Index/>,document.getElementById(\"example\"))\r\n```\r\n\r\n### TodoItem\r\n\r\n让我们想想啊，对于每一条内容来说，需要什么呢？\r\n\r\n- 一个确认是否完成的`checkbox` [ ]\r\n- 一条内容`text`\r\n- 一个删除`button`\r\n- zzzzzz.....其他的暂时先不加了~\r\n\r\n那不是太简单了 ~\r\n\r\n```html\r\n<li>\r\n  <input type=\"checkbox\"/>找工作啊找工作啊\r\n  <button>删除</button>\r\n</li>\r\n```\r\n\r\n不不不，我们现在是在写`React`,要这样：\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport {Row, Col, Checkbox, Button} from 'antd';\r\n\r\nexport default class TodoItem extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.toggleComplete = this.toggleComplete.bind(this)\r\n    this.deleteTask = this.deleteTask.bind(this)\r\n  }\r\n  toggleComplete() {\r\n    this.props.toggleComplete(this.props.taskId)\r\n  }\r\n  deleteTask() {\r\n    this.props.deleteTask(this.props.taskId)\r\n  }\r\n  render() {\r\n    let task = this.props.task\r\n    let itemChecked\r\n    if (this.props.complete === \"true\") {\r\n      task = <del>{task}</del>\r\n      itemChecked = true\r\n    } else {\r\n      itemChecked = false\r\n    }\r\n    return (\r\n      <li className=\"list-group-item\">\r\n        <Row>\r\n          <Col span={12}>\r\n            <Checkbox checked={itemChecked} onChange={this.toggleComplete}/> {task}\r\n          </Col>\r\n          <Col span={12}>\r\n            <Button type=\"danger\" className=\"pull-right\" onClick={this.deleteTask}>删除</Button>\r\n          </Col>\r\n        </Row>\r\n      </li>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n`import {Row, Col, Checkbox, Button} from 'antd'`是引入Ant Design。\r\n\r\n> 我们采用 React 封装了一套 Ant Design 的组件库，也欢迎社区其他框架的实现版本。\r\n\r\n引入这个之后，我们可以直接使用一些简单的UI组件，比如`Row`,`Col`,`Checkbox`,`Button`等，我们可以更加注重业务逻辑的实现。\r\n\r\n### TodoList\r\n\r\n接下来就是拿一个`<ul></ul>`把item包起来呗：\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport TodoItem from './todoitem';\r\nexport default class TodoList extends React.Component{\r\n  constructor(props) {\r\n    super(props);\r\n  }\r\n  render(){\r\n    var taskList=this.props.data.map(listItem=>\r\n      <TodoItem taskId={listItem.id}\r\n                key={listItem.id}\r\n                task={listItem.task}\r\n                complete={listItem.complete}\r\n                toggleComplete={this.props.toggleComplete}\r\n                deleteTask={this.props.deleteTask}/>\r\n    )\r\n    return(\r\n      <ul className=\"list-group\">\r\n        {taskList}\r\n      </ul>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n### AddTodoItem\r\n\r\n添加内容这个组件也比较简单，就只需要一个`input`和一个`button`即可：\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport {Row, Col, Form, Input, Button,notification } from 'antd';\r\nexport default class AddTodoItem extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.saveNewItem = this.saveNewItem.bind(this)\r\n  }\r\n  saveNewItem(e) {\r\n    e.preventDefault()\r\n    let element = ReactDOM.findDOMNode(this.refs.newItem)\r\n    let task = element.value\r\n    if (!task) {\r\n      notification.open({\r\n        description: 'Todo内容不得为空！',\r\n    });\r\n    } else {\r\n      this.props.saveNewItem(task)\r\n      element.value = \"\"\r\n    }\r\n  }\r\n  render() {\r\n    return (\r\n      <div className=\"addtodoitem\">\r\n        <Form.Item>\r\n          <label htmlFor=\"newItem\"></label>\r\n          <Input id=\"newItem\" ref=\"newItem\" type=\"text\" placeholder=\"吃饭睡觉打豆豆~\"></Input>\r\n          <Button type=\"primary\" className=\"pull-right\" onClick={this.saveNewItem}>保存</Button>\r\n        </Form.Item>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n### TodoBox\r\n\r\n我们的小组件已经都实现了，拿一个大`box`包起来呗 ~ \r\n\r\n```javascript\r\nimport React from 'react';\r\nimport TodoList from './todolist';\r\nimport AddTodoItem from './addtodoitem';\r\nimport {Button, Icon, Row, Col} from 'antd';\r\nexport default class TodoBox extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.state = {\r\n      data: [\r\n        {\r\n          \"id\": \"1\",\r\n          \"task\": \"做一个TodoList Demo\",\r\n          \"complete\": \"false\"\r\n        }, {\r\n          \"id\": \"2\",\r\n          \"task\": \"学习ES6\",\r\n          \"complete\": \"false\"\r\n        }, {\r\n          \"id\": \"3\",\r\n          \"task\": \"Hello React\",\r\n          \"complete\": \"true\"\r\n        }, {\r\n          \"id\": \"4\",\r\n          \"task\": \"找工作\",\r\n          \"complete\": \"false\"\r\n        }\r\n      ]\r\n    }\r\n    this.handleToggleComplete = this.handleToggleComplete.bind(this);\r\n    this.handleTaskDelete = this.handleTaskDelete.bind(this);\r\n    this.handleAddTodoItem = this.handleAddTodoItem.bind(this);\r\n  }\r\n  generateGUID() {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n      var r = Math.random() * 16 | 0,\r\n        v = c == 'x' ? r : (r & 0x3 | 0x8)\r\n      return v.toString(16)\r\n    })\r\n  }\r\n  handleToggleComplete(taskId) {\r\n    let data = this.state.data;\r\n    for (let item of data) {\r\n      if (item.id === taskId) {\r\n        item.complete = item.complete === \"true\" ? \"false\" : \"true\"\r\n      }\r\n    }\r\n    this.setState({data})\r\n  }\r\n  handleTaskDelete(taskId) {\r\n    let data = this.state.data\r\n    data = data.filter(task => task.id !== taskId)\r\n    this.setState({data})\r\n  }\r\n  handleAddTodoItem(task) {\r\n    let newItem = {\r\n      id: this.generateGUID(),\r\n      task,\r\n      complete: \"false\"\r\n    }\r\n    let data = this.state.data\r\n    data = data.concat([newItem])\r\n    this.setState({data})\r\n  }\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"well\">\r\n          <h1 className=\"text-center\">React TodoList</h1>\r\n          <TodoList data={this.state.data} toggleComplete={this.handleToggleComplete} deleteTask={this.handleTaskDelete}/>\r\n          <AddTodoItem saveNewItem={this.handleAddTodoItem}/>\r\n        </div>\r\n        <Row>\r\n          <Col span={12}></Col>\r\n          <Col span={12}>\r\n            <Button className=\"pull-left\"><Icon type=\"user\"/>\r\n              <a href=\"http://axuebin.com\">薛彬</a>\r\n            </Button>\r\n            <Button className=\"pull-right\"><Icon type=\"github\"/>\r\n              <a href=\"https://github.com/axuebin\">axuebin</a>\r\n            </Button>\r\n          </Col>\r\n        </Row>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n注意：\r\n\r\n- 通过props传递子组件需要的值和方法\r\n- 传递方法时一定要bind(this)，不然内部this会指向不正确\r\n\r\n## 源码\r\n\r\n完整的Demo代码在这：[https://github.com/axuebin/react-todolist](https://github.com/axuebin/react-todolist \"https://github.com/axuebin/react-todolist\") \r\n"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/1",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/1/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/1/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/1/events",
    "html_url": "https://github.com/axuebin/articles/issues/1",
    "id": 265627592,
    "number": 1,
    "title": "原生JS实现最简单的图片懒加载",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720883997,
        "url": "https://api.github.com/repos/axuebin/articles/labels/ES6",
        "name": "ES6",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884127,
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884524,
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-16T02:10:28Z",
    "updated_at": "2017-10-20T10:53:40Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "试一下自己撸一个图片懒加载...\r\n\r\n----\r\n\r\nDemo地址：[http://axuebin.com/lazyload](http://axuebin.com/lazyload)\r\n\r\n照片都是自己拍的哦~\r\n\r\n## 懒加载\r\n\r\n### 什么是懒加载\r\n\r\n懒加载其实就是延迟加载，是一种对网页性能优化的方式，比如当访问一个页面的时候，优先显示可视区域的图片而不一次性加载所有图片，当需要显示的时候再发送图片请求，避免打开网页时加载过多资源。\r\n\r\n### 什么时候用懒加载\r\n\r\n当页面中需要一次性载入很多图片的时候，往往都是需要用懒加载的。\r\n\r\n### 懒加载原理\r\n\r\n我们都知道HTML中的`<img>`标签是代表文档中的一个图像。。说了个废话。。\r\n\r\n`<img>`标签有一个属性是`src`，用来表示图像的URL，当这个属性的值不为空时，浏览器就会根据这个值发送请求。如果没有`src`属性，就不会发送请求。\r\n\r\n嗯？貌似这点可以利用一下？\r\n\r\n我先不设置`src`，需要的时候再设置？\r\n\r\nnice，就是这样。\r\n\r\n我们先不给`<img>`设置`src`，把图片真正的URL放在另一个属性`data-src`中，在需要的时候也就是图片进入可视区域的之前，将URL取出放到`src`中。\r\n\r\n## 实现\r\n\r\n### HTML结构\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"img-area\">\r\n    <img class=\"my-photo\" alt=\"loading\" data-src=\"./img/img1.png\">\r\n  </div>\r\n  <div class=\"img-area\">\r\n    <img class=\"my-photo\" alt=\"loading\" data-src=\"./img/img2.png\">\r\n  </div>\r\n  <div class=\"img-area\">\r\n    <img class=\"my-photo\" alt=\"loading\" data-src=\"./img/img3.png\">\r\n  </div>\r\n  <div class=\"img-area\">\r\n    <img class=\"my-photo\" alt=\"loading\" data-src=\"./img/img4.png\">\r\n  </div>\r\n  <div class=\"img-area\">\r\n    <img class=\"my-photo\" alt=\"loading\" data-src=\"./img/img5.png\">\r\n  </div>\r\n</div>\r\n```\r\n\r\n仔细观察一下，`<img>`标签此时是没有`src`属性的，只有`alt`和`data-src`属性。\r\n\r\n> alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。\r\n> data-* 全局属性：构成一类名称为自定义数据属性的属性，可以通过`HTMLElement.dataset`来访问。\r\n\r\n### 如何判断元素是否在可视区域\r\n\r\n#### 方法一\r\n\r\n网上看到好多这种方法，稍微记录一下。\r\n\r\n1. 通过`document.documentElement.clientHeight`获取屏幕可视窗口高度\r\n2. 通过`element.offsetTop`获取元素相对于文档顶部的距离\r\n3. 通过`document.documentElement.scrollTop`获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离\r\n\r\n然后判断②-③<①是否成立，如果成立，元素就在可视区域内。\r\n\r\n#### 方法二 getBoundingClientRect\r\n\r\n通过`getBoundingClientRect()`方法来获取元素的大小以及位置，MDN上是这样描述的：\r\n\r\n> The Element.getBoundingClientRect() method returns the size of an element and its position relative to the viewport.\r\n\r\n这个方法返回一个名为`ClientRect`的`DOMRect`对象，包含了`top`、`right`、`botton`、`left`、`width`、`height`这些值。\r\n\r\nMDN上有这样一张图：\r\n\r\n![](https://mdn.mozillademos.org/files/15087/rect.png)\r\n\r\n可以看出返回的元素位置是相对于左上角而言的，而不是边距。\r\n\r\n我们思考一下，什么情况下图片进入可视区域。\r\n\r\n假设`const bound = el.getBoundingClientRect();`来表示图片到可视区域顶部距离；\r\n并设 `const clientHeight = window.innerHeight;`来表示可视区域的高度。\r\n\r\n随着滚动条的向下滚动，`bound.top`会越来越小，也就是图片到可视区域顶部的距离越来越小，当`bound.top===clientHeight`时，图片的上沿应该是位于可视区域下沿的位置的临界点，再滚动一点点，图片就会进入可视区域。\r\n\r\n也就是说，在`bound.top<=clientHeight`时，图片是在可视区域内的。\r\n\r\n我们这样判断：\r\n\r\n```javascript\r\nfunction isInSight(el) {\r\n  const bound = el.getBoundingClientRect();\r\n  const clientHeight = window.innerHeight;\r\n  //如果只考虑向下滚动加载\r\n  //const clientWidth = window.innerWeight;\r\n  return bound.top <= clientHeight + 100;\r\n}\r\n```\r\n\r\n这里有个+100是为了提前加载。\r\n\r\n### 加载图片\r\n\r\n页面打开时需要对所有图片进行检查，是否在可视区域内，如果是就加载。\r\n\r\n```javascript\r\nfunction checkImgs() {\r\n  const imgs = document.querySelectorAll('.my-photo');\r\n  Array.from(imgs).forEach(el => {\r\n    if (isInSight(el)) {\r\n      loadImg(el);\r\n    }\r\n  })\r\n}\r\n\r\nfunction loadImg(el) {\r\n  if (!el.src) {\r\n    const source = el.dataset.src;\r\n    el.src = source;\r\n  }\r\n}\r\n```\r\n\r\n这里应该是有一个优化的地方，设一个标识符标识已经加载图片的index，当滚动条滚动时就不需要遍历所有的图片，只需要遍历未加载的图片即可。\r\n\r\n### 函数节流\r\n\r\n在类似于滚动条滚动等频繁的DOM操作时，总会提到“函数节流、函数去抖”。\r\n\r\n所谓的函数节流，也就是让一个函数不要执行的太频繁，减少一些过快的调用来节流。\r\n\r\n基本步骤：\r\n\r\n1. 获取第一次触发事件的时间戳\r\n2. 获取第二次触发事件的时间戳\r\n3. 时间差如果大于某个阈值就执行事件，然后重置第一个时间\r\n\r\n```javascript\r\nfunction throttle(fn, mustRun = 500) {\r\n  const timer = null;\r\n  let previous = null;\r\n  return function() {\r\n    const now = new Date();\r\n    const context = this;\r\n    const args = arguments;\r\n    if (!previous){\r\n      previous = now;\r\n    }\r\n    const remaining = now - previous;\r\n    if (mustRun && remaining >= mustRun) {\r\n      fn.apply(context, args);\r\n      previous = now;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n这里的`mustRun`就是调用函数的时间间隔，无论多么频繁的调用`fn`，只有`remaining>=mustRun`时`fn`才能被执行。\r\n\r\n## 实验\r\n\r\n### 页面打开时\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload1.png)\r\n\r\n可以看出此时仅仅是加载了img1和img2，其它的img都没发送请求，看看此时的浏览器\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload2.png)\r\n\r\n第一张图片是完整的呈现了，第二张图片刚进入可视区域，后面的就看不到了~\r\n\r\n### 页面滚动时\r\n\r\n当我向下滚动，此时浏览器是这样\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload3.png)\r\n\r\n此时第二张图片完全显示了，而第三张图片显示了一点点，这时候我们看看请求情况\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload4.png)\r\n\r\nimg3的请求发出来，而后面的请求还是没发出~\r\n\r\n### 全部载入时\r\n\r\n当滚动条滚到最底下时，全部请求都应该是发出的，如图\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/lazyload5.png)\r\n\r\n### 完整demo\r\n\r\n在这哦：[http://axuebin.com/lazyload](http://axuebin.com/lazyload)\r\n\r\n## 更新\r\n \r\n### 方法三 IntersectionObserver\r\n\r\n经大佬提醒，发现了这个方法\r\n\r\n先附上链接：\r\n\r\njjc大大：[https://github.com/justjavac/the-front-end-knowledge-you-may-dont-know/issues/10](https://github.com/justjavac/the-front-end-knowledge-you-may-dont-know/issues/10)\r\n\r\n阮一峰大大：[http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html](http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html)\r\n\r\nAPI Sketch for Intersection Observers：[https://github.com/WICG/IntersectionObserver](https://github.com/WICG/IntersectionObserver)\r\n\r\n`IntersectionObserver`可以自动观察元素是否在视口内。\r\n\r\n```javascript\r\nvar io = new IntersectionObserver(callback, option);\r\n// 开始观察\r\nio.observe(document.getElementById('example'));\r\n// 停止观察\r\nio.unobserve(element);\r\n// 关闭观察器\r\nio.disconnect();\r\n```\r\n\r\ncallback的参数是一个数组，每个数组都是一个`IntersectionObserverEntry`对象，包括以下属性：\r\n\r\n|属性               |描述                                                                                          |\r\n| ---------------- | -------------------------------------------------------------------------------------------- |\r\n|time              |可见性发生变化的时间，单位为毫秒                                                                  |\r\n|rootBounds        |与getBoundingClientRect()方法的返回值一样                                                       |\r\n|boundingClientRect|目标元素的矩形区域的信息                                                                         |\r\n|intersectionRect  |目标元素与视口（或根元素）的交叉区域的信息                                                         |\r\n|intersectionRatio |目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0|\r\n|target            |被观察的目标元素，是一个 DOM 节点对象                                                             |\r\n\r\n我们需要用到`intersectionRatio`来判断是否在可视区域内，当`intersectionRatio > 0 && intersectionRatio <= 1`即在可视区域内。\r\n\r\n#### 代码\r\n\r\n```javascript\r\nfunction checkImgs() {\r\n  const imgs = Array.from(document.querySelectorAll(\".my-photo\"));\r\n  imgs.forEach(item => io.observe(item));\r\n}\r\n\r\nfunction loadImg(el) {\r\n  if (!el.src) {\r\n    const source = el.dataset.src;\r\n    el.src = source;\r\n  }\r\n}\r\n\r\nconst io = new IntersectionObserver(ioes => {\r\n  ioes.forEach(ioe => {\r\n    const el = ioe.target;\r\n    const intersectionRatio = ioe.intersectionRatio;\r\n    if (intersectionRatio > 0 && intersectionRatio <= 1) {\r\n      loadImg(el);\r\n    }\r\n    el.onload = el.onerror = () => io.unobserve(el);\r\n  });\r\n});\r\n```"
  }
]
